{"ast":null,"code":"/**\n * Servicio de audio mejorado para encuestas por voz\n * Implementa síntesis y reconocimiento de voz con temporizaciones naturales\n */\n\nclass AudioService {\n  constructor() {\n    // Variables de estado para síntesis de voz\n    this.cachedVoices = null;\n    this.isSpeaking = false;\n    this.currentUtterance = null;\n    this.resumeInterval = null;\n    this.utteranceTimeoutId = null;\n\n    // Variables para reconocimiento de voz\n    this.recognition = null;\n    this.isListening = false;\n    this.recognitionLang = 'es-ES';\n    this.finalTranscript = '';\n    this.interimTranscript = '';\n    this.microphoneStream = null;\n    this.permissionGranted = false;\n    this.permissionCallback = null;\n\n    // Inicializar sistema al crear instancia\n    this.initSpeechSystem();\n  }\n\n  /**\n   * Inicializa el sistema de síntesis y precarga las voces\n   */\n  initSpeechSystem() {\n    // Verificar si la API está disponible\n    if (typeof window === 'undefined' || !window.speechSynthesis) {\n      console.error('AudioService: Speech Synthesis no está disponible en este navegador');\n      return false;\n    }\n\n    // Obtener y cachear las voces disponibles\n    const loadVoices = () => {\n      const voices = window.speechSynthesis.getVoices();\n      if (voices.length > 0) {\n        this.cachedVoices = voices;\n\n        // Log información sobre las voces disponibles\n        console.log(`AudioService: ${voices.length} voces disponibles`);\n\n        // Buscar voces en español\n        const spanishVoices = voices.filter(v => v.lang.includes('es') || v.name.toLowerCase().includes('spanish'));\n        if (spanishVoices.length > 0) {\n          console.log('AudioService: Voces en español disponibles:', spanishVoices.map(v => `${v.name} (${v.lang})`).join(', '));\n        } else {\n          console.warn('AudioService: No se encontraron voces en español');\n        }\n      }\n    };\n\n    // Chrome requiere este evento\n    if (window.speechSynthesis.onvoiceschanged !== undefined) {\n      window.speechSynthesis.onvoiceschanged = loadVoices;\n    }\n\n    // Intentar cargar las voces inmediatamente también\n    loadVoices();\n    return true;\n  }\n\n  /**\n   * Verifica si el sistema está actualmente hablando\n   */\n  checkIfSpeaking() {\n    return window.speechSynthesis && window.speechSynthesis.speaking;\n  }\n\n  /**\n   * Detiene cualquier síntesis de voz en curso\n   */\n  cancelSpeech() {\n    if (!window.speechSynthesis) return;\n\n    // Cancelar cualquier síntesis en curso\n    window.speechSynthesis.cancel();\n\n    // Limpiar temporizadores\n    if (this.resumeInterval) {\n      clearInterval(this.resumeInterval);\n      this.resumeInterval = null;\n    }\n    if (this.utteranceTimeoutId) {\n      clearTimeout(this.utteranceTimeoutId);\n      this.utteranceTimeoutId = null;\n    }\n    this.isSpeaking = false;\n    this.currentUtterance = null;\n  }\n\n  /**\n   * Habla el texto dado usando técnicas avanzadas para mejorar la confiabilidad\n   * Incluye manejo de tiempos naturales entre frases\n   */\n  speakText(text, onStarted, onEnded, onError) {\n    if (!text || text.trim() === '') {\n      if (onError) onError('Texto vacío');\n      return () => {};\n    }\n    if (typeof window === 'undefined' || !window.speechSynthesis) {\n      if (onError) onError('Speech Synthesis no está disponible en este navegador');\n      return () => {};\n    }\n\n    // Si ya estamos hablando, crear una cola temporal\n    if (this.isSpeaking) {\n      console.log('AudioService: Ya estamos hablando, esperando...');\n      // Cancelamos la síntesis actual y esperamos un momento antes de comenzar la nueva\n      this.cancelSpeech();\n\n      // Esperar 500ms para asegurar que termine la síntesis anterior\n      setTimeout(() => {\n        this.speakText(text, onStarted, onEnded, onError);\n      }, 500);\n      return () => {};\n    }\n    try {\n      // Marcar que estamos hablando ahora\n      this.isSpeaking = true;\n\n      // Crear el objeto de síntesis\n      const utterance = new SpeechSynthesisUtterance(text);\n      this.currentUtterance = utterance;\n\n      // Configurar parámetros básicos\n      utterance.lang = 'es-ES';\n      utterance.rate = 1.0; // Velocidad normal\n      utterance.pitch = 1.0; // Tono normal\n      utterance.volume = 1.0; // Volumen máximo\n\n      // Obtener voces y seleccionar una voz en español si está disponible\n      const voices = this.cachedVoices || window.speechSynthesis.getVoices();\n      const spanishVoice = voices.find(voice => voice.lang.includes('es') || voice.name.toLowerCase().includes('spanish'));\n      if (spanishVoice) {\n        console.log(`AudioService: Usando voz ${spanishVoice.name}`);\n        utterance.voice = spanishVoice;\n      } else if (voices.length > 0) {\n        console.log(`AudioService: No hay voces en español, usando ${voices[0].name}`);\n        utterance.voice = voices[0];\n      }\n\n      // Configurar eventos\n      utterance.onstart = () => {\n        console.log('AudioService: Síntesis iniciada');\n        if (onStarted) onStarted();\n      };\n      utterance.onend = () => {\n        console.log('AudioService: Síntesis completada');\n        this.isSpeaking = false;\n\n        // Limpiar temporizadores\n        if (this.resumeInterval) {\n          clearInterval(this.resumeInterval);\n          this.resumeInterval = null;\n        }\n        if (this.utteranceTimeoutId) {\n          clearTimeout(this.utteranceTimeoutId);\n          this.utteranceTimeoutId = null;\n        }\n\n        // Esperar un momento antes de llamar al callback para simular una pausa natural\n        setTimeout(() => {\n          if (onEnded) onEnded();\n        }, 300);\n      };\n      utterance.onerror = event => {\n        console.error('AudioService: Error en síntesis:', event);\n        this.isSpeaking = false;\n\n        // Limpiar temporizadores\n        if (this.resumeInterval) {\n          clearInterval(this.resumeInterval);\n          this.resumeInterval = null;\n        }\n        if (this.utteranceTimeoutId) {\n          clearTimeout(this.utteranceTimeoutId);\n          this.utteranceTimeoutId = null;\n        }\n        if (onError) onError(event.error || 'Error desconocido');\n      };\n\n      // Cancelar cualquier síntesis previa\n      window.speechSynthesis.cancel();\n\n      // Iniciar síntesis después de una breve pausa para evitar conflictos\n      setTimeout(() => {\n        // Iniciar la síntesis\n        window.speechSynthesis.speak(utterance);\n\n        // *** WORKAROUNDS CRÍTICOS ***\n\n        // 1. Workaround para el problema de Chrome donde la síntesis se detiene después de ~15s\n        this.resumeInterval = setInterval(() => {\n          if (window.speechSynthesis.speaking) {\n            console.log('AudioService: Aplicando workaround de pausa/resume');\n            window.speechSynthesis.pause();\n            window.speechSynthesis.resume();\n          } else {\n            clearInterval(this.resumeInterval);\n            this.resumeInterval = null;\n          }\n        }, 10000);\n\n        // 2. Workaround para el caso donde onend no se dispara\n        // Tiempo basado en la longitud del texto (100ms por caracter) con un mínimo de 6 segundos\n        const maxSpeakingTime = Math.max(6000, text.length * 100);\n        this.utteranceTimeoutId = setTimeout(() => {\n          if (window.speechSynthesis.speaking) {\n            console.log(`AudioService: Detectado posible bloqueo después de ${maxSpeakingTime}ms, forzando finalización`);\n            window.speechSynthesis.cancel();\n            this.isSpeaking = false;\n            if (onEnded) onEnded();\n          }\n          if (this.resumeInterval) {\n            clearInterval(this.resumeInterval);\n            this.resumeInterval = null;\n          }\n        }, maxSpeakingTime);\n      }, 100);\n      return () => {\n        this.cancelSpeech();\n      };\n    } catch (error) {\n      console.error('AudioService: Error general:', error);\n      this.isSpeaking = false;\n      if (onError) onError(error.message || 'Error desconocido');\n      return () => {};\n    }\n  }\n\n  /**\n   * Inicializa el reconocimiento de voz\n   * @param {string} language - Idioma para el reconocimiento (por defecto es español)\n   */\n  init(language = 'es-ES') {\n    if (!this.isSupportedByBrowser()) {\n      console.error('El reconocimiento de voz no está soportado en este navegador');\n      return false;\n    }\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    this.recognition = new SpeechRecognition();\n\n    // Configurar opciones\n    this.recognition.lang = language;\n    this.recognition.continuous = false;\n    this.recognition.interimResults = true;\n\n    // Configurar eventos\n    this.recognition.onresult = event => {\n      const transcript = Array.from(event.results).map(result => result[0]).map(result => result.transcript).join('');\n      this.finalTranscript = transcript;\n      if (this.onResultCallback) {\n        this.onResultCallback(transcript, event.results[0].isFinal);\n      }\n    };\n    this.recognition.onend = () => {\n      this.isListening = false;\n      if (this.onEndCallback) {\n        this.onEndCallback(this.finalTranscript);\n      }\n    };\n    this.recognition.onerror = event => {\n      console.log('AudioService: Error de reconocimiento:', event.error);\n      this.isListening = false;\n\n      // Solo propagar errores significativos, no aquellos que son parte normal del flujo\n      // como 'no-speech' que puede ocurrir durante pausas normales\n      if (event.error === 'no-speech') {\n        // Para errores de no-speech, intentamos reiniciar si el usuario está en un entorno silencioso\n        // pero enviamos un mensaje más amigable\n        if (this.onErrorCallback) {\n          this.onErrorCallback('waiting');\n        }\n\n        // Intentar reiniciar tras un breve retraso\n        setTimeout(() => {\n          if (!this.isListening) {\n            // Solo si aún no estamos escuchando\n            try {\n              this.recognition.start();\n              this.isListening = true;\n            } catch (e) {\n              console.error('Error al reiniciar reconocimiento:', e);\n            }\n          }\n        }, 1000);\n      } else if (this.onErrorCallback) {\n        // Para otros errores, enviamos el mensaje original\n        this.onErrorCallback(event.error);\n      }\n    };\n    return true;\n  }\n\n  /**\n   * Solicita permiso para usar el micrófono\n   * @returns {Promise<boolean>} - Promise que resuelve a true si se otorgó permiso, false en caso contrario\n   */\n  async requestMicrophonePermission() {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      try {\n        // Solicitar acceso al micrófono\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true\n        });\n        // Almacenar la referencia al stream para poder detenerlo después\n        this.microphoneStream = stream;\n        this.permissionGranted = true;\n\n        // Notificar que el permiso fue concedido si hay un callback\n        if (this.permissionCallback) {\n          this.permissionCallback(true);\n        }\n        return true;\n      } catch (error) {\n        console.error('Error al solicitar permiso para el micrófono:', error);\n        this.permissionGranted = false;\n        // Notificar que el permiso fue denegado si hay un callback\n        if (this.permissionCallback) {\n          this.permissionCallback(false, error.message);\n        }\n        return false;\n      }\n    } else {\n      console.error('getUserMedia no está soportado en este navegador');\n      return false;\n    }\n  }\n\n  /**\n   * Establece el callback para cuando cambia el estado del permiso del micrófono\n   * @param {Function} callback - Función a llamar cuando cambia el estado del permiso\n   */\n  onPermissionChange(callback) {\n    this.permissionCallback = callback;\n  }\n\n  /**\n   * Inicia el reconocimiento de voz, solicitando permisos si es necesario\n   * @returns {Promise<boolean>} - Promise que resuelve a true si se inició correctamente\n   */\n  async start() {\n    // Detener cualquier reconocimiento previo primero\n    this.stop();\n\n    // Pequeña pausa para asegurar que el reconocimiento anterior se detuvo correctamente\n    await new Promise(resolve => setTimeout(resolve, 300));\n\n    // Verificar y solicitar permiso si no ha sido otorgado\n    if (!this.permissionGranted) {\n      const permissionGranted = await this.requestMicrophonePermission();\n      if (!permissionGranted) {\n        if (this.onErrorCallback) {\n          this.onErrorCallback('No se otorgó permiso para usar el micrófono');\n        }\n        return false;\n      }\n    }\n    if (!this.recognition) {\n      const initialized = this.init();\n      if (!initialized) return false;\n    }\n\n    // Reiniciar transcripciones\n    this.finalTranscript = '';\n    this.interimTranscript = '';\n    try {\n      console.log('AudioService: Iniciando reconocimiento de voz');\n      this.recognition.start();\n      this.isListening = true;\n      return true;\n    } catch (error) {\n      console.error('Error al iniciar el reconocimiento de voz:', error);\n      if (error.name === 'NotAllowedError') {\n        // Reintentar permisos\n        this.permissionGranted = false;\n        return this.start();\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Detiene el reconocimiento de voz\n   */\n  stop() {\n    if (this.recognition && this.isListening) {\n      try {\n        this.recognition.stop();\n        this.isListening = false;\n\n        // También detener el stream del micrófono si existe\n        if (this.microphoneStream) {\n          this.microphoneStream.getTracks().forEach(track => track.stop());\n        }\n        return true;\n      } catch (error) {\n        console.error('Error al detener el reconocimiento de voz:', error);\n        return false;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Establece el callback para cuando se recibe un resultado\n   * @param {Function} callback - Función a llamar con el resultado\n   */\n  onResult(callback) {\n    this.onResultCallback = callback;\n  }\n\n  /**\n   * Establece el callback para cuando termina el reconocimiento\n   * @param {Function} callback - Función a llamar al terminar\n   */\n  onEnd(callback) {\n    this.onEndCallback = callback;\n  }\n\n  /**\n   * Establece el callback para cuando ocurre un error\n   * @param {Function} callback - Función a llamar en caso de error\n   */\n  onError(callback) {\n    this.onErrorCallback = callback;\n  }\n\n  /**\n   * Verifica si el navegador soporta reconocimiento de voz\n   * @returns {boolean} - true si es soportado, false si no\n   */\n  isSupportedByBrowser() {\n    return typeof window !== 'undefined' && ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window);\n  }\n}\n\n// Exportar una instancia única del servicio\nconst audioService = new AudioService();\nexport default audioService;","map":{"version":3,"names":["AudioService","constructor","cachedVoices","isSpeaking","currentUtterance","resumeInterval","utteranceTimeoutId","recognition","isListening","recognitionLang","finalTranscript","interimTranscript","microphoneStream","permissionGranted","permissionCallback","initSpeechSystem","window","speechSynthesis","console","error","loadVoices","voices","getVoices","length","log","spanishVoices","filter","v","lang","includes","name","toLowerCase","map","join","warn","onvoiceschanged","undefined","checkIfSpeaking","speaking","cancelSpeech","cancel","clearInterval","clearTimeout","speakText","text","onStarted","onEnded","onError","trim","setTimeout","utterance","SpeechSynthesisUtterance","rate","pitch","volume","spanishVoice","find","voice","onstart","onend","onerror","event","speak","setInterval","pause","resume","maxSpeakingTime","Math","max","message","init","language","isSupportedByBrowser","SpeechRecognition","webkitSpeechRecognition","continuous","interimResults","onresult","transcript","Array","from","results","result","onResultCallback","isFinal","onEndCallback","onErrorCallback","start","e","requestMicrophonePermission","navigator","mediaDevices","getUserMedia","stream","audio","onPermissionChange","callback","stop","Promise","resolve","initialized","getTracks","forEach","track","onResult","onEnd","audioService"],"sources":["C:/Users/josep/Documents/Sistema de Encuestas por Voz/client/src/services/audioService.js"],"sourcesContent":["/**\n * Servicio de audio mejorado para encuestas por voz\n * Implementa síntesis y reconocimiento de voz con temporizaciones naturales\n */\n\nclass AudioService {\n  constructor() {\n    // Variables de estado para síntesis de voz\n    this.cachedVoices = null;\n    this.isSpeaking = false;\n    this.currentUtterance = null;\n    this.resumeInterval = null;\n    this.utteranceTimeoutId = null;\n    \n    // Variables para reconocimiento de voz\n    this.recognition = null;\n    this.isListening = false;\n    this.recognitionLang = 'es-ES';\n    this.finalTranscript = '';\n    this.interimTranscript = '';\n    this.microphoneStream = null;\n    this.permissionGranted = false;\n    this.permissionCallback = null;\n    \n    // Inicializar sistema al crear instancia\n    this.initSpeechSystem();\n  }\n  \n  /**\n   * Inicializa el sistema de síntesis y precarga las voces\n   */\n  initSpeechSystem() {\n    // Verificar si la API está disponible\n    if (typeof window === 'undefined' || !window.speechSynthesis) {\n      console.error('AudioService: Speech Synthesis no está disponible en este navegador');\n      return false;\n    }\n  \n    // Obtener y cachear las voces disponibles\n    const loadVoices = () => {\n      const voices = window.speechSynthesis.getVoices();\n      if (voices.length > 0) {\n        this.cachedVoices = voices;\n        \n        // Log información sobre las voces disponibles\n        console.log(`AudioService: ${voices.length} voces disponibles`);\n        \n        // Buscar voces en español\n        const spanishVoices = voices.filter(v => \n          v.lang.includes('es') || \n          v.name.toLowerCase().includes('spanish')\n        );\n        \n        if (spanishVoices.length > 0) {\n          console.log('AudioService: Voces en español disponibles:', \n            spanishVoices.map(v => `${v.name} (${v.lang})`).join(', ')\n          );\n        } else {\n          console.warn('AudioService: No se encontraron voces en español');\n        }\n      }\n    };\n  \n    // Chrome requiere este evento\n    if (window.speechSynthesis.onvoiceschanged !== undefined) {\n      window.speechSynthesis.onvoiceschanged = loadVoices;\n    }\n  \n    // Intentar cargar las voces inmediatamente también\n    loadVoices();\n  \n    return true;\n  }\n\n  /**\n   * Verifica si el sistema está actualmente hablando\n   */\n  checkIfSpeaking() {\n    return window.speechSynthesis && window.speechSynthesis.speaking;\n  }\n\n  /**\n   * Detiene cualquier síntesis de voz en curso\n   */\n  cancelSpeech() {\n    if (!window.speechSynthesis) return;\n    \n    // Cancelar cualquier síntesis en curso\n    window.speechSynthesis.cancel();\n    \n    // Limpiar temporizadores\n    if (this.resumeInterval) {\n      clearInterval(this.resumeInterval);\n      this.resumeInterval = null;\n    }\n    \n    if (this.utteranceTimeoutId) {\n      clearTimeout(this.utteranceTimeoutId);\n      this.utteranceTimeoutId = null;\n    }\n    \n    this.isSpeaking = false;\n    this.currentUtterance = null;\n  }\n\n  /**\n   * Habla el texto dado usando técnicas avanzadas para mejorar la confiabilidad\n   * Incluye manejo de tiempos naturales entre frases\n   */\n  speakText(text, onStarted, onEnded, onError) {\n    if (!text || text.trim() === '') {\n      if (onError) onError('Texto vacío');\n      return () => {};\n    }\n    \n    if (typeof window === 'undefined' || !window.speechSynthesis) {\n      if (onError) onError('Speech Synthesis no está disponible en este navegador');\n      return () => {};\n    }\n    \n    // Si ya estamos hablando, crear una cola temporal\n    if (this.isSpeaking) {\n      console.log('AudioService: Ya estamos hablando, esperando...');\n      // Cancelamos la síntesis actual y esperamos un momento antes de comenzar la nueva\n      this.cancelSpeech();\n      \n      // Esperar 500ms para asegurar que termine la síntesis anterior\n      setTimeout(() => {\n        this.speakText(text, onStarted, onEnded, onError);\n      }, 500);\n      \n      return () => {};\n    }\n    \n    try {\n      // Marcar que estamos hablando ahora\n      this.isSpeaking = true;\n      \n      // Crear el objeto de síntesis\n      const utterance = new SpeechSynthesisUtterance(text);\n      this.currentUtterance = utterance;\n      \n      // Configurar parámetros básicos\n      utterance.lang = 'es-ES';\n      utterance.rate = 1.0;     // Velocidad normal\n      utterance.pitch = 1.0;    // Tono normal\n      utterance.volume = 1.0;   // Volumen máximo\n      \n      // Obtener voces y seleccionar una voz en español si está disponible\n      const voices = this.cachedVoices || window.speechSynthesis.getVoices();\n      const spanishVoice = voices.find(voice => \n        voice.lang.includes('es') || \n        voice.name.toLowerCase().includes('spanish')\n      );\n      \n      if (spanishVoice) {\n        console.log(`AudioService: Usando voz ${spanishVoice.name}`);\n        utterance.voice = spanishVoice;\n      } else if (voices.length > 0) {\n        console.log(`AudioService: No hay voces en español, usando ${voices[0].name}`);\n        utterance.voice = voices[0];\n      }\n      \n      // Configurar eventos\n      utterance.onstart = () => {\n        console.log('AudioService: Síntesis iniciada');\n        if (onStarted) onStarted();\n      };\n      \n      utterance.onend = () => {\n        console.log('AudioService: Síntesis completada');\n        this.isSpeaking = false;\n        \n        // Limpiar temporizadores\n        if (this.resumeInterval) {\n          clearInterval(this.resumeInterval);\n          this.resumeInterval = null;\n        }\n        \n        if (this.utteranceTimeoutId) {\n          clearTimeout(this.utteranceTimeoutId);\n          this.utteranceTimeoutId = null;\n        }\n        \n        // Esperar un momento antes de llamar al callback para simular una pausa natural\n        setTimeout(() => {\n          if (onEnded) onEnded();\n        }, 300);\n      };\n      \n      utterance.onerror = (event) => {\n        console.error('AudioService: Error en síntesis:', event);\n        this.isSpeaking = false;\n        \n        // Limpiar temporizadores\n        if (this.resumeInterval) {\n          clearInterval(this.resumeInterval);\n          this.resumeInterval = null;\n        }\n        \n        if (this.utteranceTimeoutId) {\n          clearTimeout(this.utteranceTimeoutId);\n          this.utteranceTimeoutId = null;\n        }\n        \n        if (onError) onError(event.error || 'Error desconocido');\n      };\n      \n      // Cancelar cualquier síntesis previa\n      window.speechSynthesis.cancel();\n      \n      // Iniciar síntesis después de una breve pausa para evitar conflictos\n      setTimeout(() => {\n        // Iniciar la síntesis\n        window.speechSynthesis.speak(utterance);\n        \n        // *** WORKAROUNDS CRÍTICOS ***\n        \n        // 1. Workaround para el problema de Chrome donde la síntesis se detiene después de ~15s\n        this.resumeInterval = setInterval(() => {\n          if (window.speechSynthesis.speaking) {\n            console.log('AudioService: Aplicando workaround de pausa/resume');\n            window.speechSynthesis.pause();\n            window.speechSynthesis.resume();\n          } else {\n            clearInterval(this.resumeInterval);\n            this.resumeInterval = null;\n          }\n        }, 10000);\n        \n        // 2. Workaround para el caso donde onend no se dispara\n        // Tiempo basado en la longitud del texto (100ms por caracter) con un mínimo de 6 segundos\n        const maxSpeakingTime = Math.max(6000, text.length * 100);\n        this.utteranceTimeoutId = setTimeout(() => {\n          if (window.speechSynthesis.speaking) {\n            console.log(`AudioService: Detectado posible bloqueo después de ${maxSpeakingTime}ms, forzando finalización`);\n            window.speechSynthesis.cancel();\n            this.isSpeaking = false;\n            \n            if (onEnded) onEnded();\n          }\n          \n          if (this.resumeInterval) {\n            clearInterval(this.resumeInterval);\n            this.resumeInterval = null;\n          }\n        }, maxSpeakingTime);\n      }, 100);\n      \n      return () => {\n        this.cancelSpeech();\n      };\n    } catch (error) {\n      console.error('AudioService: Error general:', error);\n      this.isSpeaking = false;\n      if (onError) onError(error.message || 'Error desconocido');\n      return () => {};\n    }\n  }\n\n  /**\n   * Inicializa el reconocimiento de voz\n   * @param {string} language - Idioma para el reconocimiento (por defecto es español)\n   */\n  init(language = 'es-ES') {\n    if (!this.isSupportedByBrowser()) {\n      console.error('El reconocimiento de voz no está soportado en este navegador');\n      return false;\n    }\n    \n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    this.recognition = new SpeechRecognition();\n    \n    // Configurar opciones\n    this.recognition.lang = language;\n    this.recognition.continuous = false;\n    this.recognition.interimResults = true;\n    \n    // Configurar eventos\n    this.recognition.onresult = (event) => {\n      const transcript = Array.from(event.results)\n        .map(result => result[0])\n        .map(result => result.transcript)\n        .join('');\n      \n      this.finalTranscript = transcript;\n      \n      if (this.onResultCallback) {\n        this.onResultCallback(transcript, event.results[0].isFinal);\n      }\n    };\n    \n    this.recognition.onend = () => {\n      this.isListening = false;\n      if (this.onEndCallback) {\n        this.onEndCallback(this.finalTranscript);\n      }\n    };\n    \n    this.recognition.onerror = (event) => {\n      console.log('AudioService: Error de reconocimiento:', event.error);\n      this.isListening = false;\n      \n      // Solo propagar errores significativos, no aquellos que son parte normal del flujo\n      // como 'no-speech' que puede ocurrir durante pausas normales\n      if (event.error === 'no-speech') {\n        // Para errores de no-speech, intentamos reiniciar si el usuario está en un entorno silencioso\n        // pero enviamos un mensaje más amigable\n        if (this.onErrorCallback) {\n          this.onErrorCallback('waiting');\n        }\n        \n        // Intentar reiniciar tras un breve retraso\n        setTimeout(() => {\n          if (!this.isListening) { // Solo si aún no estamos escuchando\n            try {\n              this.recognition.start();\n              this.isListening = true;\n            } catch (e) {\n              console.error('Error al reiniciar reconocimiento:', e);\n            }\n          }\n        }, 1000);\n      } else if (this.onErrorCallback) {\n        // Para otros errores, enviamos el mensaje original\n        this.onErrorCallback(event.error);\n      }\n    };\n    \n    return true;\n  }\n\n  /**\n   * Solicita permiso para usar el micrófono\n   * @returns {Promise<boolean>} - Promise que resuelve a true si se otorgó permiso, false en caso contrario\n   */\n  async requestMicrophonePermission() {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      try {\n        // Solicitar acceso al micrófono\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n        // Almacenar la referencia al stream para poder detenerlo después\n        this.microphoneStream = stream;\n        this.permissionGranted = true;\n        \n        // Notificar que el permiso fue concedido si hay un callback\n        if (this.permissionCallback) {\n          this.permissionCallback(true);\n        }\n        \n        return true;\n      } catch (error) {\n        console.error('Error al solicitar permiso para el micrófono:', error);\n        \n        this.permissionGranted = false;\n        // Notificar que el permiso fue denegado si hay un callback\n        if (this.permissionCallback) {\n          this.permissionCallback(false, error.message);\n        }\n        \n        return false;\n      }\n    } else {\n      console.error('getUserMedia no está soportado en este navegador');\n      return false;\n    }\n  }\n\n  /**\n   * Establece el callback para cuando cambia el estado del permiso del micrófono\n   * @param {Function} callback - Función a llamar cuando cambia el estado del permiso\n   */\n  onPermissionChange(callback) {\n    this.permissionCallback = callback;\n  }\n\n  /**\n   * Inicia el reconocimiento de voz, solicitando permisos si es necesario\n   * @returns {Promise<boolean>} - Promise que resuelve a true si se inició correctamente\n   */\n  async start() {\n    // Detener cualquier reconocimiento previo primero\n    this.stop();\n    \n    // Pequeña pausa para asegurar que el reconocimiento anterior se detuvo correctamente\n    await new Promise(resolve => setTimeout(resolve, 300));\n    \n    // Verificar y solicitar permiso si no ha sido otorgado\n    if (!this.permissionGranted) {\n      const permissionGranted = await this.requestMicrophonePermission();\n      if (!permissionGranted) {\n        if (this.onErrorCallback) {\n          this.onErrorCallback('No se otorgó permiso para usar el micrófono');\n        }\n        return false;\n      }\n    }\n    \n    if (!this.recognition) {\n      const initialized = this.init();\n      if (!initialized) return false;\n    }\n    \n    // Reiniciar transcripciones\n    this.finalTranscript = '';\n    this.interimTranscript = '';\n    \n    try {\n      console.log('AudioService: Iniciando reconocimiento de voz');\n      this.recognition.start();\n      this.isListening = true;\n      return true;\n    } catch (error) {\n      console.error('Error al iniciar el reconocimiento de voz:', error);\n      if (error.name === 'NotAllowedError') {\n        // Reintentar permisos\n        this.permissionGranted = false;\n        return this.start();\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Detiene el reconocimiento de voz\n   */\n  stop() {\n    if (this.recognition && this.isListening) {\n      try {\n        this.recognition.stop();\n        this.isListening = false;\n        \n        // También detener el stream del micrófono si existe\n        if (this.microphoneStream) {\n          this.microphoneStream.getTracks().forEach(track => track.stop());\n        }\n        \n        return true;\n      } catch (error) {\n        console.error('Error al detener el reconocimiento de voz:', error);\n        return false;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Establece el callback para cuando se recibe un resultado\n   * @param {Function} callback - Función a llamar con el resultado\n   */\n  onResult(callback) {\n    this.onResultCallback = callback;\n  }\n\n  /**\n   * Establece el callback para cuando termina el reconocimiento\n   * @param {Function} callback - Función a llamar al terminar\n   */\n  onEnd(callback) {\n    this.onEndCallback = callback;\n  }\n\n  /**\n   * Establece el callback para cuando ocurre un error\n   * @param {Function} callback - Función a llamar en caso de error\n   */\n  onError(callback) {\n    this.onErrorCallback = callback;\n  }\n\n  /**\n   * Verifica si el navegador soporta reconocimiento de voz\n   * @returns {boolean} - true si es soportado, false si no\n   */\n  isSupportedByBrowser() {\n    return typeof window !== 'undefined' && \n      ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window);\n  }\n}\n\n// Exportar una instancia única del servicio\nconst audioService = new AudioService();\nexport default audioService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}