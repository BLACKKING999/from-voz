{"ast":null,"code":"import nlp from 'compromise';\n\n/**\n * Servicio de procesamiento de lenguaje natural para mejorar las interacciones por voz\n * Utiliza compromise.js, una biblioteca ligera de NLP para el navegador\n */\n\n/**\n * Extraer nombre de una frase con procesamiento avanzado de lenguaje natural\n * @param {string} text - Texto del cual extraer el nombre\n * @returns {string} - Nombre extraído o valor por defecto\n */\nexport const extractName = text => {\n  if (!text || typeof text !== 'string') {\n    return 'Estimado participante';\n  }\n\n  // Procesar el texto con NLP\n  const doc = nlp(text);\n\n  // Verificar si es una pregunta\n  if (doc.questions().length > 0) {\n    console.log('NLP: Se detectó una pregunta en lugar de un nombre');\n    return null;\n  }\n\n  // Intentar extraer nombre propio (mejor precisión que regex)\n  const people = doc.people().out('array');\n  if (people.length > 0) {\n    console.log('NLP: Nombre extraído usando reconocimiento de entidades:', people[0]);\n    return people[0];\n  }\n\n  // Extraer frases de presentación\n  const presentationPhrases = ['me llamo', 'mi nombre es', 'soy', 'yo soy', 'puedes llamarme', 'puede llamarme', 'llámame', 'llamame'];\n  let cleanedText = text.trim();\n  for (const phrase of presentationPhrases) {\n    if (text.toLowerCase().includes(phrase)) {\n      // Extraer texto después de la frase\n      const parts = text.toLowerCase().split(phrase);\n      if (parts.length > 1 && parts[1].trim()) {\n        cleanedText = parts[1].trim();\n        break;\n      }\n    }\n  }\n\n  // Eliminar palabras comunes y saludos\n  const commonWords = ['gracias', 'por favor', 'hola', 'buenos días', 'buenas tardes', 'señor', 'señora'];\n  commonWords.forEach(word => {\n    cleanedText = cleanedText.replace(new RegExp(`\\\\b${word}\\\\b`, 'gi'), '');\n  });\n\n  // Eliminar múltiples espacios y puntuación\n  cleanedText = cleanedText.replace(/\\s+/g, ' ').trim();\n  cleanedText = cleanedText.replace(/[.,;:!?]/g, '').trim();\n  if (!cleanedText) {\n    return 'Estimado participante';\n  }\n\n  // Tomar las primeras palabras (máximo 3) como nombre\n  const words = cleanedText.split(' ');\n  const nameWords = words.slice(0, Math.min(3, words.length));\n\n  // Capitalizar cada palabra del nombre\n  return nameWords.map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\n};\n\n/**\n * Analiza la intención del usuario a partir de su respuesta\n * @param {string} text - Texto de entrada\n * @returns {Object} - Objeto con la intención detectada y confianza\n */\nexport const analyzeIntent = text => {\n  if (!text) return {\n    intent: 'unknown',\n    confidence: 0\n  };\n  const doc = nlp(text);\n\n  // Detectar si es una pregunta\n  if (doc.questions().length > 0) {\n    return {\n      intent: 'question',\n      confidence: 0.9\n    };\n  }\n\n  // Detectar afirmación/negación\n  const affirmations = ['sí', 'si', 'claro', 'por supuesto', 'afirmativo', 'correcto', 'exacto'];\n  const negations = ['no', 'nope', 'negativo', 'para nada', 'en absoluto', 'nunca'];\n  const lowerText = text.toLowerCase();\n  for (const word of affirmations) {\n    if (lowerText.includes(word)) {\n      return {\n        intent: 'affirmation',\n        confidence: 0.85\n      };\n    }\n  }\n  for (const word of negations) {\n    if (lowerText.includes(word)) {\n      return {\n        intent: 'negation',\n        confidence: 0.85\n      };\n    }\n  }\n\n  // Detectar números (para preguntas de calificación)\n  const numbers = doc.numbers().out('array');\n  if (numbers.length > 0) {\n    return {\n      intent: 'number',\n      value: numbers[0],\n      confidence: 0.9\n    };\n  }\n  return {\n    intent: 'statement',\n    confidence: 0.5\n  };\n};\n\n/**\n * Procesa la respuesta para una pregunta según su tipo\n * @param {string} text - Respuesta del usuario\n * @param {string} questionType - Tipo de pregunta ('yesno', 'rating', 'text')\n * @returns {*} - Respuesta procesada (boolean, number o string)\n */\nexport const processResponse = (text, questionType) => {\n  if (!text) return null;\n  const intent = analyzeIntent(text);\n  console.log('NLP: Intención detectada:', intent);\n  switch (questionType) {\n    case 'yesno':\n      if (intent.intent === 'affirmation') return true;\n      if (intent.intent === 'negation') return false;\n      // Analizar el texto para encontrar afirmación/negación más compleja\n      const isPositive = nlp(text).sentiment() > 0;\n      return isPositive;\n    case 'rating':\n      if (intent.intent === 'number' && intent.value >= 1 && intent.value <= 5) {\n        return intent.value;\n      }\n      // Extraer número del texto\n      const numbers = nlp(text).numbers().out('array');\n      if (numbers.length > 0) {\n        let num = parseInt(numbers[0]);\n        // Limitar al rango 1-5\n        return Math.max(1, Math.min(5, num));\n      }\n      return null;\n    case 'text':\n    default:\n      // Limpiar el texto para obtener la respuesta más relevante\n      const doc = nlp(text);\n      // Eliminar muletillas comunes\n      return doc.out('text');\n  }\n};\n\n/**\n * Analiza el sentimiento de un texto (positivo, negativo, neutral)\n * @param {string} text - Texto a analizar\n * @returns {Object} - Objeto con el sentimiento y su intensidad\n */\nexport const analyzeSentiment = text => {\n  if (!text) return {\n    sentiment: 'neutral',\n    score: 0\n  };\n  const doc = nlp(text);\n  const score = doc.sentiment();\n  let sentiment = 'neutral';\n  if (score > 0.2) sentiment = 'positive';else if (score < -0.2) sentiment = 'negative';\n  return {\n    sentiment,\n    score\n  };\n};\n\n/**\n * Genera una respuesta personalizada basada en el sentimiento del usuario\n * @param {string} userText - Texto del usuario\n * @param {Array} possibleResponses - Array de posibles respuestas\n * @returns {string} - Respuesta seleccionada\n */\nexport const generateAdaptiveResponse = (userText, possibleResponses) => {\n  const sentiment = analyzeSentiment(userText);\n\n  // Clasificar respuestas según el sentimiento\n  const positiveResponses = possibleResponses.filter(r => r.tone === 'positive');\n  const neutralResponses = possibleResponses.filter(r => r.tone === 'neutral');\n  const negativeResponses = possibleResponses.filter(r => r.tone === 'supportive');\n\n  // Seleccionar respuesta apropiada según el sentimiento del usuario\n  let selectedResponses;\n  if (sentiment.sentiment === 'positive') {\n    selectedResponses = positiveResponses.length ? positiveResponses : neutralResponses;\n  } else if (sentiment.sentiment === 'negative') {\n    selectedResponses = negativeResponses.length ? negativeResponses : neutralResponses;\n  } else {\n    selectedResponses = neutralResponses.length ? neutralResponses : positiveResponses;\n  }\n\n  // Si no hay respuestas del tipo adecuado, usar cualquiera\n  if (!selectedResponses.length) {\n    selectedResponses = possibleResponses;\n  }\n\n  // Elegir aleatoriamente entre las respuestas apropiadas\n  const randomIndex = Math.floor(Math.random() * selectedResponses.length);\n  return selectedResponses[randomIndex].text;\n};\nexport default {\n  extractName,\n  analyzeIntent,\n  processResponse,\n  analyzeSentiment,\n  generateAdaptiveResponse\n};","map":{"version":3,"names":["nlp","extractName","text","doc","questions","length","console","log","people","out","presentationPhrases","cleanedText","trim","phrase","toLowerCase","includes","parts","split","commonWords","forEach","word","replace","RegExp","words","nameWords","slice","Math","min","map","charAt","toUpperCase","join","analyzeIntent","intent","confidence","affirmations","negations","lowerText","numbers","value","processResponse","questionType","isPositive","sentiment","num","parseInt","max","analyzeSentiment","score","generateAdaptiveResponse","userText","possibleResponses","positiveResponses","filter","r","tone","neutralResponses","negativeResponses","selectedResponses","randomIndex","floor","random"],"sources":["C:/Users/josep/Documents/Sistema de Encuestas por Voz/client/src/services/nlpService.js"],"sourcesContent":["import nlp from 'compromise';\n\n/**\n * Servicio de procesamiento de lenguaje natural para mejorar las interacciones por voz\n * Utiliza compromise.js, una biblioteca ligera de NLP para el navegador\n */\n\n/**\n * Extraer nombre de una frase con procesamiento avanzado de lenguaje natural\n * @param {string} text - Texto del cual extraer el nombre\n * @returns {string} - Nombre extraído o valor por defecto\n */\nexport const extractName = (text) => {\n  if (!text || typeof text !== 'string') {\n    return 'Estimado participante';\n  }\n\n  // Procesar el texto con NLP\n  const doc = nlp(text);\n  \n  // Verificar si es una pregunta\n  if (doc.questions().length > 0) {\n    console.log('NLP: Se detectó una pregunta en lugar de un nombre');\n    return null;\n  }\n  \n  // Intentar extraer nombre propio (mejor precisión que regex)\n  const people = doc.people().out('array');\n  if (people.length > 0) {\n    console.log('NLP: Nombre extraído usando reconocimiento de entidades:', people[0]);\n    return people[0];\n  }\n  \n  // Extraer frases de presentación\n  const presentationPhrases = ['me llamo', 'mi nombre es', 'soy', 'yo soy', \n    'puedes llamarme', 'puede llamarme', 'llámame', 'llamame'];\n  \n  let cleanedText = text.trim();\n  for (const phrase of presentationPhrases) {\n    if (text.toLowerCase().includes(phrase)) {\n      // Extraer texto después de la frase\n      const parts = text.toLowerCase().split(phrase);\n      if (parts.length > 1 && parts[1].trim()) {\n        cleanedText = parts[1].trim();\n        break;\n      }\n    }\n  }\n  \n  // Eliminar palabras comunes y saludos\n  const commonWords = ['gracias', 'por favor', 'hola', 'buenos días', 'buenas tardes', 'señor', 'señora'];\n  commonWords.forEach(word => {\n    cleanedText = cleanedText.replace(new RegExp(`\\\\b${word}\\\\b`, 'gi'), '');\n  });\n  \n  // Eliminar múltiples espacios y puntuación\n  cleanedText = cleanedText.replace(/\\s+/g, ' ').trim();\n  cleanedText = cleanedText.replace(/[.,;:!?]/g, '').trim();\n  \n  if (!cleanedText) {\n    return 'Estimado participante';\n  }\n  \n  // Tomar las primeras palabras (máximo 3) como nombre\n  const words = cleanedText.split(' ');\n  const nameWords = words.slice(0, Math.min(3, words.length));\n  \n  // Capitalizar cada palabra del nombre\n  return nameWords\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join(' ');\n};\n\n/**\n * Analiza la intención del usuario a partir de su respuesta\n * @param {string} text - Texto de entrada\n * @returns {Object} - Objeto con la intención detectada y confianza\n */\nexport const analyzeIntent = (text) => {\n  if (!text) return { intent: 'unknown', confidence: 0 };\n  \n  const doc = nlp(text);\n  \n  // Detectar si es una pregunta\n  if (doc.questions().length > 0) {\n    return { intent: 'question', confidence: 0.9 };\n  }\n  \n  // Detectar afirmación/negación\n  const affirmations = ['sí', 'si', 'claro', 'por supuesto', 'afirmativo', 'correcto', 'exacto'];\n  const negations = ['no', 'nope', 'negativo', 'para nada', 'en absoluto', 'nunca'];\n  \n  const lowerText = text.toLowerCase();\n  \n  for (const word of affirmations) {\n    if (lowerText.includes(word)) {\n      return { intent: 'affirmation', confidence: 0.85 };\n    }\n  }\n  \n  for (const word of negations) {\n    if (lowerText.includes(word)) {\n      return { intent: 'negation', confidence: 0.85 };\n    }\n  }\n  \n  // Detectar números (para preguntas de calificación)\n  const numbers = doc.numbers().out('array');\n  if (numbers.length > 0) {\n    return { intent: 'number', value: numbers[0], confidence: 0.9 };\n  }\n  \n  return { intent: 'statement', confidence: 0.5 };\n};\n\n/**\n * Procesa la respuesta para una pregunta según su tipo\n * @param {string} text - Respuesta del usuario\n * @param {string} questionType - Tipo de pregunta ('yesno', 'rating', 'text')\n * @returns {*} - Respuesta procesada (boolean, number o string)\n */\nexport const processResponse = (text, questionType) => {\n  if (!text) return null;\n  \n  const intent = analyzeIntent(text);\n  console.log('NLP: Intención detectada:', intent);\n  \n  switch (questionType) {\n    case 'yesno':\n      if (intent.intent === 'affirmation') return true;\n      if (intent.intent === 'negation') return false;\n      // Analizar el texto para encontrar afirmación/negación más compleja\n      const isPositive = nlp(text).sentiment() > 0;\n      return isPositive;\n      \n    case 'rating':\n      if (intent.intent === 'number' && intent.value >= 1 && intent.value <= 5) {\n        return intent.value;\n      }\n      // Extraer número del texto\n      const numbers = nlp(text).numbers().out('array');\n      if (numbers.length > 0) {\n        let num = parseInt(numbers[0]);\n        // Limitar al rango 1-5\n        return Math.max(1, Math.min(5, num));\n      }\n      return null;\n      \n    case 'text':\n    default:\n      // Limpiar el texto para obtener la respuesta más relevante\n      const doc = nlp(text);\n      // Eliminar muletillas comunes\n      return doc.out('text');\n  }\n};\n\n/**\n * Analiza el sentimiento de un texto (positivo, negativo, neutral)\n * @param {string} text - Texto a analizar\n * @returns {Object} - Objeto con el sentimiento y su intensidad\n */\nexport const analyzeSentiment = (text) => {\n  if (!text) return { sentiment: 'neutral', score: 0 };\n  \n  const doc = nlp(text);\n  const score = doc.sentiment();\n  \n  let sentiment = 'neutral';\n  if (score > 0.2) sentiment = 'positive';\n  else if (score < -0.2) sentiment = 'negative';\n  \n  return { sentiment, score };\n};\n\n/**\n * Genera una respuesta personalizada basada en el sentimiento del usuario\n * @param {string} userText - Texto del usuario\n * @param {Array} possibleResponses - Array de posibles respuestas\n * @returns {string} - Respuesta seleccionada\n */\nexport const generateAdaptiveResponse = (userText, possibleResponses) => {\n  const sentiment = analyzeSentiment(userText);\n  \n  // Clasificar respuestas según el sentimiento\n  const positiveResponses = possibleResponses.filter(r => r.tone === 'positive');\n  const neutralResponses = possibleResponses.filter(r => r.tone === 'neutral');\n  const negativeResponses = possibleResponses.filter(r => r.tone === 'supportive');\n  \n  // Seleccionar respuesta apropiada según el sentimiento del usuario\n  let selectedResponses;\n  if (sentiment.sentiment === 'positive') {\n    selectedResponses = positiveResponses.length ? positiveResponses : neutralResponses;\n  } else if (sentiment.sentiment === 'negative') {\n    selectedResponses = negativeResponses.length ? negativeResponses : neutralResponses;\n  } else {\n    selectedResponses = neutralResponses.length ? neutralResponses : positiveResponses;\n  }\n  \n  // Si no hay respuestas del tipo adecuado, usar cualquiera\n  if (!selectedResponses.length) {\n    selectedResponses = possibleResponses;\n  }\n  \n  // Elegir aleatoriamente entre las respuestas apropiadas\n  const randomIndex = Math.floor(Math.random() * selectedResponses.length);\n  return selectedResponses[randomIndex].text;\n};\n\nexport default {\n  extractName,\n  analyzeIntent,\n  processResponse,\n  analyzeSentiment,\n  generateAdaptiveResponse\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}