{"ast":null,"code":"/**\n * Servicio de síntesis de voz optimizado para navegadores\n * Implementa técnicas avanzadas para mejorar la confiabilidad de la API de Speech Synthesis\n */\n\n// Cache de voces para evitar búsquedas repetidas\nlet cachedVoices = null;\n\n/**\n * Obtiene todas las voces disponibles en el navegador\n */\nconst getVoices = () => {\n  if (cachedVoices) return cachedVoices;\n  return window.speechSynthesis ? window.speechSynthesis.getVoices() : [];\n};\n\n/**\n * Inicializa el sistema de síntesis y precarga las voces\n * Esto debe llamarse al inicio de la aplicación\n */\nconst initSpeechSystem = () => {\n  // Verificar si la API está disponible\n  if (typeof window === 'undefined' || !window.speechSynthesis) {\n    console.error('Speech Synthesis no está disponible en este navegador');\n    return false;\n  }\n\n  // Obtener y cachear las voces disponibles\n  const loadVoices = () => {\n    const voices = window.speechSynthesis.getVoices();\n    if (voices.length > 0) {\n      cachedVoices = voices;\n\n      // Log información sobre las voces disponibles\n      console.log(`AudioService: ${voices.length} voces disponibles`);\n\n      // Buscar voces en español\n      const spanishVoices = voices.filter(v => v.lang.includes('es') || v.name.toLowerCase().includes('spanish'));\n      if (spanishVoices.length > 0) {\n        console.log('AudioService: Voces en español disponibles:', spanishVoices.map(v => `${v.name} (${v.lang})`).join(', '));\n      } else {\n        console.warn('AudioService: No se encontraron voces en español');\n      }\n    }\n  };\n\n  // Chrome requiere este evento\n  if (window.speechSynthesis.onvoiceschanged !== undefined) {\n    window.speechSynthesis.onvoiceschanged = loadVoices;\n  }\n\n  // Intentar cargar las voces inmediatamente también\n  loadVoices();\n  return true;\n};\n\n/**\n * Habla el texto dado usando técnicas avanzadas para mejorar la confiabilidad\n */\nconst speakText = (text, onStarted, onEnded, onError) => {\n  if (typeof window === 'undefined' || !window.speechSynthesis) {\n    if (onError) onError('Speech Synthesis no está disponible en este navegador');\n    return () => {};\n  }\n  if (!text || text.trim() === '') {\n    if (onError) onError('Texto vacío');\n    return () => {};\n  }\n  try {\n    // Limpiar cualquier síntesis en curso\n    window.speechSynthesis.cancel();\n\n    // Crear el objeto de síntesis\n    const utterance = new SpeechSynthesisUtterance(text);\n\n    // Configurar parámetros básicos\n    utterance.lang = 'es-ES';\n    utterance.rate = 1.0; // Velocidad normal\n    utterance.pitch = 1.0; // Tono normal\n    utterance.volume = 1.0; // Volumen máximo\n\n    // Obtener voces y seleccionar una voz en español si está disponible\n    const voices = getVoices();\n    const spanishVoice = voices.find(voice => voice.lang.includes('es') || voice.name.toLowerCase().includes('spanish'));\n    if (spanishVoice) {\n      console.log(`AudioService: Usando voz ${spanishVoice.name}`);\n      utterance.voice = spanishVoice;\n    } else if (voices.length > 0) {\n      console.log(`AudioService: No hay voces en español, usando ${voices[0].name}`);\n      utterance.voice = voices[0];\n    }\n\n    // Configurar eventos\n    utterance.onstart = () => {\n      console.log('AudioService: Síntesis iniciada');\n      if (onStarted) onStarted();\n    };\n    utterance.onend = () => {\n      console.log('AudioService: Síntesis completada');\n      if (onEnded) onEnded();\n    };\n    utterance.onerror = event => {\n      console.error('AudioService: Error en síntesis:', event);\n      if (onError) onError(event.error || 'Error desconocido');\n    };\n\n    // Iniciar síntesis\n    window.speechSynthesis.speak(utterance);\n\n    // *** WORKAROUNDS CRÍTICOS ***\n\n    // 1. Workaround para el problema de Chrome donde la síntesis se detiene después de ~15s\n    const resumeInterval = setInterval(() => {\n      if (window.speechSynthesis.speaking) {\n        console.log('AudioService: Aplicando workaround de pausa/resume');\n        window.speechSynthesis.pause();\n        window.speechSynthesis.resume();\n      } else {\n        clearInterval(resumeInterval);\n      }\n    }, 10000);\n\n    // 2. Workaround para el caso donde onend no se dispara\n    const maxSpeakingTime = Math.max(5000, text.length * 80); // ~80ms por caracter\n    const timeoutId = setTimeout(() => {\n      if (window.speechSynthesis.speaking) {\n        console.log(`AudioService: Detectado posible bloqueo después de ${maxSpeakingTime}ms, forzando finalización`);\n        window.speechSynthesis.cancel();\n        if (onEnded) onEnded();\n      }\n      clearInterval(resumeInterval);\n    }, maxSpeakingTime);\n\n    // Función para detener la síntesis\n    return () => {\n      clearTimeout(timeoutId);\n      clearInterval(resumeInterval);\n      window.speechSynthesis.cancel();\n    };\n  } catch (error) {\n    console.error('AudioService: Error general:', error);\n    if (onError) onError(error.message || 'Error desconocido');\n    return () => {};\n  }\n};\n\n/**\n * Servicio para manejar la funcionalidad de reconocimiento de voz\n */\n\nclass AudioService {\n  constructor() {\n    this.recognition = null;\n    this.isSupported = typeof window !== 'undefined' && ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window);\n    this.isListening = false;\n    this.transcript = '';\n    this.onResultCallback = null;\n    this.onEndCallback = null;\n    this.onErrorCallback = null;\n    this.permissionGranted = false;\n    this.permissionCallback = null;\n  }\n\n  /**\n   * Inicializa el reconocimiento de voz\n   * @param {string} language - Idioma para el reconocimiento (por defecto es español)\n   */\n  init(language = 'es-ES') {\n    if (!this.isSupported) {\n      console.error('El reconocimiento de voz no está soportado en este navegador');\n      return false;\n    }\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    this.recognition = new SpeechRecognition();\n\n    // Configurar opciones\n    this.recognition.lang = language;\n    this.recognition.continuous = false;\n    this.recognition.interimResults = true;\n\n    // Configurar eventos\n    this.recognition.onresult = event => {\n      const transcript = Array.from(event.results).map(result => result[0]).map(result => result.transcript).join('');\n      this.transcript = transcript;\n      if (this.onResultCallback) {\n        this.onResultCallback(transcript, event.results[0].isFinal);\n      }\n    };\n    this.recognition.onend = () => {\n      this.isListening = false;\n      if (this.onEndCallback) {\n        this.onEndCallback(this.transcript);\n      }\n    };\n    this.recognition.onerror = event => {\n      this.isListening = false;\n      if (this.onErrorCallback) {\n        this.onErrorCallback(event.error);\n      }\n    };\n    return true;\n  }\n\n  /**\n   * Solicita permiso para usar el micrófono\n   * @returns {Promise<boolean>} - Promise que resuelve a true si se otorgó permiso, false en caso contrario\n   */\n  async requestMicrophonePermission() {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      try {\n        // Solicitar acceso al micrófono\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true\n        });\n        // Almacenar la referencia al stream para poder detenerlo después\n        this.microphoneStream = stream;\n        this.permissionGranted = true;\n\n        // Notificar que el permiso fue concedido si hay un callback\n        if (this.permissionCallback) {\n          this.permissionCallback(true);\n        }\n        return true;\n      } catch (error) {\n        console.error('Error al solicitar permiso para el micrófono:', error);\n        this.permissionGranted = false;\n        // Notificar que el permiso fue denegado si hay un callback\n        if (this.permissionCallback) {\n          this.permissionCallback(false, error.message);\n        }\n        return false;\n      }\n    } else {\n      console.error('getUserMedia no está soportado en este navegador');\n      return false;\n    }\n  }\n\n  /**\n   * Establece el callback para cuando cambia el estado del permiso del micrófono\n   * @param {Function} callback - Función a llamar cuando cambia el estado del permiso\n   */\n  onPermissionChange(callback) {\n    this.permissionCallback = callback;\n  }\n\n  /**\n   * Inicia el reconocimiento de voz, solicitando permisos si es necesario\n   * @returns {Promise<boolean>} - Promise que resuelve a true si se inició correctamente\n   */\n  async start() {\n    // Verificar y solicitar permiso si no ha sido otorgado\n    if (!this.permissionGranted) {\n      const permissionGranted = await this.requestMicrophonePermission();\n      if (!permissionGranted) {\n        if (this.onErrorCallback) {\n          this.onErrorCallback('No se otorgó permiso para usar el micrófono');\n        }\n        return false;\n      }\n    }\n    if (!this.recognition) {\n      const initialized = this.init();\n      if (!initialized) return false;\n    }\n    try {\n      this.recognition.start();\n      this.isListening = true;\n      return true;\n    } catch (error) {\n      console.error('Error al iniciar el reconocimiento de voz:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Detiene el reconocimiento de voz\n   */\n  stop() {\n    if (this.recognition && this.isListening) {\n      try {\n        this.recognition.stop();\n        this.isListening = false;\n\n        // También detener el stream del micrófono si existe\n        if (this.microphoneStream) {\n          this.microphoneStream.getTracks().forEach(track => track.stop());\n        }\n        return true;\n      } catch (error) {\n        console.error('Error al detener el reconocimiento de voz:', error);\n        return false;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Establece el callback para cuando se recibe un resultado\n   * @param {Function} callback - Función a llamar con el resultado\n   */\n  onResult(callback) {\n    this.onResultCallback = callback;\n  }\n\n  /**\n   * Establece el callback para cuando termina el reconocimiento\n   * @param {Function} callback - Función a llamar al terminar\n   */\n  onEnd(callback) {\n    this.onEndCallback = callback;\n  }\n\n  /**\n   * Establece el callback para cuando ocurre un error\n   * @param {Function} callback - Función a llamar en caso de error\n   */\n  onError(callback) {\n    this.onErrorCallback = callback;\n  }\n\n  /**\n   * Verifica si el navegador soporta reconocimiento de voz\n   * @returns {boolean} - true si es soportado, false si no\n   */\n  isSupportedByBrowser() {\n    return this.isSupported;\n  }\n\n  /**\n   * Inicializa el sistema de síntesis de voz\n   */\n  initSpeechSystem() {\n    return initSpeechSystem();\n  }\n\n  /**\n   * Habla un texto usando la síntesis de voz\n   */\n  speakText(text, onStarted, onEnded, onError) {\n    return speakText(text, onStarted, onEnded, onError);\n  }\n}\n\n// Exportar una instancia única del servicio\nconst audioService = new AudioService();\nexport default audioService;","map":{"version":3,"names":["cachedVoices","getVoices","window","speechSynthesis","initSpeechSystem","console","error","loadVoices","voices","length","log","spanishVoices","filter","v","lang","includes","name","toLowerCase","map","join","warn","onvoiceschanged","undefined","speakText","text","onStarted","onEnded","onError","trim","cancel","utterance","SpeechSynthesisUtterance","rate","pitch","volume","spanishVoice","find","voice","onstart","onend","onerror","event","speak","resumeInterval","setInterval","speaking","pause","resume","clearInterval","maxSpeakingTime","Math","max","timeoutId","setTimeout","clearTimeout","message","AudioService","constructor","recognition","isSupported","isListening","transcript","onResultCallback","onEndCallback","onErrorCallback","permissionGranted","permissionCallback","init","language","SpeechRecognition","webkitSpeechRecognition","continuous","interimResults","onresult","Array","from","results","result","isFinal","requestMicrophonePermission","navigator","mediaDevices","getUserMedia","stream","audio","microphoneStream","onPermissionChange","callback","start","initialized","stop","getTracks","forEach","track","onResult","onEnd","isSupportedByBrowser","audioService"],"sources":["C:/Users/josep/Documents/Sistema de Encuestas por Voz/client/src/services/audioService.js"],"sourcesContent":["/**\n * Servicio de síntesis de voz optimizado para navegadores\n * Implementa técnicas avanzadas para mejorar la confiabilidad de la API de Speech Synthesis\n */\n\n// Cache de voces para evitar búsquedas repetidas\nlet cachedVoices = null;\n\n/**\n * Obtiene todas las voces disponibles en el navegador\n */\nconst getVoices = () => {\n  if (cachedVoices) return cachedVoices;\n  \n  return window.speechSynthesis ? window.speechSynthesis.getVoices() : [];\n};\n\n/**\n * Inicializa el sistema de síntesis y precarga las voces\n * Esto debe llamarse al inicio de la aplicación\n */\nconst initSpeechSystem = () => {\n  // Verificar si la API está disponible\n  if (typeof window === 'undefined' || !window.speechSynthesis) {\n    console.error('Speech Synthesis no está disponible en este navegador');\n    return false;\n  }\n  \n  // Obtener y cachear las voces disponibles\n  const loadVoices = () => {\n    const voices = window.speechSynthesis.getVoices();\n    if (voices.length > 0) {\n      cachedVoices = voices;\n      \n      // Log información sobre las voces disponibles\n      console.log(`AudioService: ${voices.length} voces disponibles`);\n      \n      // Buscar voces en español\n      const spanishVoices = voices.filter(v => \n        v.lang.includes('es') || \n        v.name.toLowerCase().includes('spanish')\n      );\n      \n      if (spanishVoices.length > 0) {\n        console.log('AudioService: Voces en español disponibles:', \n          spanishVoices.map(v => `${v.name} (${v.lang})`).join(', ')\n        );\n      } else {\n        console.warn('AudioService: No se encontraron voces en español');\n      }\n    }\n  };\n  \n  // Chrome requiere este evento\n  if (window.speechSynthesis.onvoiceschanged !== undefined) {\n    window.speechSynthesis.onvoiceschanged = loadVoices;\n  }\n  \n  // Intentar cargar las voces inmediatamente también\n  loadVoices();\n  \n  return true;\n};\n\n/**\n * Habla el texto dado usando técnicas avanzadas para mejorar la confiabilidad\n */\nconst speakText = (text, onStarted, onEnded, onError) => {\n  if (typeof window === 'undefined' || !window.speechSynthesis) {\n    if (onError) onError('Speech Synthesis no está disponible en este navegador');\n    return () => {};\n  }\n  \n  if (!text || text.trim() === '') {\n    if (onError) onError('Texto vacío');\n    return () => {};\n  }\n  \n  try {\n    // Limpiar cualquier síntesis en curso\n    window.speechSynthesis.cancel();\n    \n    // Crear el objeto de síntesis\n    const utterance = new SpeechSynthesisUtterance(text);\n    \n    // Configurar parámetros básicos\n    utterance.lang = 'es-ES';\n    utterance.rate = 1.0;     // Velocidad normal\n    utterance.pitch = 1.0;    // Tono normal\n    utterance.volume = 1.0;   // Volumen máximo\n    \n    // Obtener voces y seleccionar una voz en español si está disponible\n    const voices = getVoices();\n    const spanishVoice = voices.find(voice => \n      voice.lang.includes('es') || \n      voice.name.toLowerCase().includes('spanish')\n    );\n    \n    if (spanishVoice) {\n      console.log(`AudioService: Usando voz ${spanishVoice.name}`);\n      utterance.voice = spanishVoice;\n    } else if (voices.length > 0) {\n      console.log(`AudioService: No hay voces en español, usando ${voices[0].name}`);\n      utterance.voice = voices[0];\n    }\n    \n    // Configurar eventos\n    utterance.onstart = () => {\n      console.log('AudioService: Síntesis iniciada');\n      if (onStarted) onStarted();\n    };\n    \n    utterance.onend = () => {\n      console.log('AudioService: Síntesis completada');\n      if (onEnded) onEnded();\n    };\n    \n    utterance.onerror = (event) => {\n      console.error('AudioService: Error en síntesis:', event);\n      if (onError) onError(event.error || 'Error desconocido');\n    };\n    \n    // Iniciar síntesis\n    window.speechSynthesis.speak(utterance);\n    \n    // *** WORKAROUNDS CRÍTICOS ***\n    \n    // 1. Workaround para el problema de Chrome donde la síntesis se detiene después de ~15s\n    const resumeInterval = setInterval(() => {\n      if (window.speechSynthesis.speaking) {\n        console.log('AudioService: Aplicando workaround de pausa/resume');\n        window.speechSynthesis.pause();\n        window.speechSynthesis.resume();\n      } else {\n        clearInterval(resumeInterval);\n      }\n    }, 10000);\n    \n    // 2. Workaround para el caso donde onend no se dispara\n    const maxSpeakingTime = Math.max(5000, text.length * 80); // ~80ms por caracter\n    const timeoutId = setTimeout(() => {\n      if (window.speechSynthesis.speaking) {\n        console.log(`AudioService: Detectado posible bloqueo después de ${maxSpeakingTime}ms, forzando finalización`);\n        window.speechSynthesis.cancel();\n        if (onEnded) onEnded();\n      }\n      clearInterval(resumeInterval);\n    }, maxSpeakingTime);\n    \n    // Función para detener la síntesis\n    return () => {\n      clearTimeout(timeoutId);\n      clearInterval(resumeInterval);\n      window.speechSynthesis.cancel();\n    };\n    \n  } catch (error) {\n    console.error('AudioService: Error general:', error);\n    if (onError) onError(error.message || 'Error desconocido');\n    return () => {};\n  }\n};\n\n/**\n * Servicio para manejar la funcionalidad de reconocimiento de voz\n */\n\nclass AudioService {\n  constructor() {\n    this.recognition = null;\n    this.isSupported = typeof window !== 'undefined' && \n      ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window);\n    this.isListening = false;\n    this.transcript = '';\n    this.onResultCallback = null;\n    this.onEndCallback = null;\n    this.onErrorCallback = null;\n    this.permissionGranted = false;\n    this.permissionCallback = null;\n  }\n\n  /**\n   * Inicializa el reconocimiento de voz\n   * @param {string} language - Idioma para el reconocimiento (por defecto es español)\n   */\n  init(language = 'es-ES') {\n    if (!this.isSupported) {\n      console.error('El reconocimiento de voz no está soportado en este navegador');\n      return false;\n    }\n\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    this.recognition = new SpeechRecognition();\n    \n    // Configurar opciones\n    this.recognition.lang = language;\n    this.recognition.continuous = false;\n    this.recognition.interimResults = true;\n    \n    // Configurar eventos\n    this.recognition.onresult = (event) => {\n      const transcript = Array.from(event.results)\n        .map(result => result[0])\n        .map(result => result.transcript)\n        .join('');\n      \n      this.transcript = transcript;\n      \n      if (this.onResultCallback) {\n        this.onResultCallback(transcript, event.results[0].isFinal);\n      }\n    };\n    \n    this.recognition.onend = () => {\n      this.isListening = false;\n      if (this.onEndCallback) {\n        this.onEndCallback(this.transcript);\n      }\n    };\n    \n    this.recognition.onerror = (event) => {\n      this.isListening = false;\n      if (this.onErrorCallback) {\n        this.onErrorCallback(event.error);\n      }\n    };\n    \n    return true;\n  }\n\n  /**\n   * Solicita permiso para usar el micrófono\n   * @returns {Promise<boolean>} - Promise que resuelve a true si se otorgó permiso, false en caso contrario\n   */\n  async requestMicrophonePermission() {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      try {\n        // Solicitar acceso al micrófono\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n        // Almacenar la referencia al stream para poder detenerlo después\n        this.microphoneStream = stream;\n        this.permissionGranted = true;\n        \n        // Notificar que el permiso fue concedido si hay un callback\n        if (this.permissionCallback) {\n          this.permissionCallback(true);\n        }\n        \n        return true;\n      } catch (error) {\n        console.error('Error al solicitar permiso para el micrófono:', error);\n        \n        this.permissionGranted = false;\n        // Notificar que el permiso fue denegado si hay un callback\n        if (this.permissionCallback) {\n          this.permissionCallback(false, error.message);\n        }\n        \n        return false;\n      }\n    } else {\n      console.error('getUserMedia no está soportado en este navegador');\n      return false;\n    }\n  }\n\n  /**\n   * Establece el callback para cuando cambia el estado del permiso del micrófono\n   * @param {Function} callback - Función a llamar cuando cambia el estado del permiso\n   */\n  onPermissionChange(callback) {\n    this.permissionCallback = callback;\n  }\n\n  /**\n   * Inicia el reconocimiento de voz, solicitando permisos si es necesario\n   * @returns {Promise<boolean>} - Promise que resuelve a true si se inició correctamente\n   */\n  async start() {\n    // Verificar y solicitar permiso si no ha sido otorgado\n    if (!this.permissionGranted) {\n      const permissionGranted = await this.requestMicrophonePermission();\n      if (!permissionGranted) {\n        if (this.onErrorCallback) {\n          this.onErrorCallback('No se otorgó permiso para usar el micrófono');\n        }\n        return false;\n      }\n    }\n    \n    if (!this.recognition) {\n      const initialized = this.init();\n      if (!initialized) return false;\n    }\n    \n    try {\n      this.recognition.start();\n      this.isListening = true;\n      return true;\n    } catch (error) {\n      console.error('Error al iniciar el reconocimiento de voz:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Detiene el reconocimiento de voz\n   */\n  stop() {\n    if (this.recognition && this.isListening) {\n      try {\n        this.recognition.stop();\n        this.isListening = false;\n        \n        // También detener el stream del micrófono si existe\n        if (this.microphoneStream) {\n          this.microphoneStream.getTracks().forEach(track => track.stop());\n        }\n        \n        return true;\n      } catch (error) {\n        console.error('Error al detener el reconocimiento de voz:', error);\n        return false;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Establece el callback para cuando se recibe un resultado\n   * @param {Function} callback - Función a llamar con el resultado\n   */\n  onResult(callback) {\n    this.onResultCallback = callback;\n  }\n\n  /**\n   * Establece el callback para cuando termina el reconocimiento\n   * @param {Function} callback - Función a llamar al terminar\n   */\n  onEnd(callback) {\n    this.onEndCallback = callback;\n  }\n\n  /**\n   * Establece el callback para cuando ocurre un error\n   * @param {Function} callback - Función a llamar en caso de error\n   */\n  onError(callback) {\n    this.onErrorCallback = callback;\n  }\n\n  /**\n   * Verifica si el navegador soporta reconocimiento de voz\n   * @returns {boolean} - true si es soportado, false si no\n   */\n  isSupportedByBrowser() {\n    return this.isSupported;\n  }\n  \n  /**\n   * Inicializa el sistema de síntesis de voz\n   */\n  initSpeechSystem() {\n    return initSpeechSystem();\n  }\n  \n  /**\n   * Habla un texto usando la síntesis de voz\n   */\n  speakText(text, onStarted, onEnded, onError) {\n    return speakText(text, onStarted, onEnded, onError);\n  }\n}\n\n// Exportar una instancia única del servicio\nconst audioService = new AudioService();\nexport default audioService;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA,IAAIA,YAAY,GAAG,IAAI;;AAEvB;AACA;AACA;AACA,MAAMC,SAAS,GAAGA,CAAA,KAAM;EACtB,IAAID,YAAY,EAAE,OAAOA,YAAY;EAErC,OAAOE,MAAM,CAACC,eAAe,GAAGD,MAAM,CAACC,eAAe,CAACF,SAAS,CAAC,CAAC,GAAG,EAAE;AACzE,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMG,gBAAgB,GAAGA,CAAA,KAAM;EAC7B;EACA,IAAI,OAAOF,MAAM,KAAK,WAAW,IAAI,CAACA,MAAM,CAACC,eAAe,EAAE;IAC5DE,OAAO,CAACC,KAAK,CAAC,uDAAuD,CAAC;IACtE,OAAO,KAAK;EACd;;EAEA;EACA,MAAMC,UAAU,GAAGA,CAAA,KAAM;IACvB,MAAMC,MAAM,GAAGN,MAAM,CAACC,eAAe,CAACF,SAAS,CAAC,CAAC;IACjD,IAAIO,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;MACrBT,YAAY,GAAGQ,MAAM;;MAErB;MACAH,OAAO,CAACK,GAAG,CAAC,iBAAiBF,MAAM,CAACC,MAAM,oBAAoB,CAAC;;MAE/D;MACA,MAAME,aAAa,GAAGH,MAAM,CAACI,MAAM,CAACC,CAAC,IACnCA,CAAC,CAACC,IAAI,CAACC,QAAQ,CAAC,IAAI,CAAC,IACrBF,CAAC,CAACG,IAAI,CAACC,WAAW,CAAC,CAAC,CAACF,QAAQ,CAAC,SAAS,CACzC,CAAC;MAED,IAAIJ,aAAa,CAACF,MAAM,GAAG,CAAC,EAAE;QAC5BJ,OAAO,CAACK,GAAG,CAAC,6CAA6C,EACvDC,aAAa,CAACO,GAAG,CAACL,CAAC,IAAI,GAAGA,CAAC,CAACG,IAAI,KAAKH,CAAC,CAACC,IAAI,GAAG,CAAC,CAACK,IAAI,CAAC,IAAI,CAC3D,CAAC;MACH,CAAC,MAAM;QACLd,OAAO,CAACe,IAAI,CAAC,kDAAkD,CAAC;MAClE;IACF;EACF,CAAC;;EAED;EACA,IAAIlB,MAAM,CAACC,eAAe,CAACkB,eAAe,KAAKC,SAAS,EAAE;IACxDpB,MAAM,CAACC,eAAe,CAACkB,eAAe,GAAGd,UAAU;EACrD;;EAEA;EACAA,UAAU,CAAC,CAAC;EAEZ,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA,MAAMgB,SAAS,GAAGA,CAACC,IAAI,EAAEC,SAAS,EAAEC,OAAO,EAAEC,OAAO,KAAK;EACvD,IAAI,OAAOzB,MAAM,KAAK,WAAW,IAAI,CAACA,MAAM,CAACC,eAAe,EAAE;IAC5D,IAAIwB,OAAO,EAAEA,OAAO,CAAC,uDAAuD,CAAC;IAC7E,OAAO,MAAM,CAAC,CAAC;EACjB;EAEA,IAAI,CAACH,IAAI,IAAIA,IAAI,CAACI,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;IAC/B,IAAID,OAAO,EAAEA,OAAO,CAAC,aAAa,CAAC;IACnC,OAAO,MAAM,CAAC,CAAC;EACjB;EAEA,IAAI;IACF;IACAzB,MAAM,CAACC,eAAe,CAAC0B,MAAM,CAAC,CAAC;;IAE/B;IACA,MAAMC,SAAS,GAAG,IAAIC,wBAAwB,CAACP,IAAI,CAAC;;IAEpD;IACAM,SAAS,CAAChB,IAAI,GAAG,OAAO;IACxBgB,SAAS,CAACE,IAAI,GAAG,GAAG,CAAC,CAAK;IAC1BF,SAAS,CAACG,KAAK,GAAG,GAAG,CAAC,CAAI;IAC1BH,SAAS,CAACI,MAAM,GAAG,GAAG,CAAC,CAAG;;IAE1B;IACA,MAAM1B,MAAM,GAAGP,SAAS,CAAC,CAAC;IAC1B,MAAMkC,YAAY,GAAG3B,MAAM,CAAC4B,IAAI,CAACC,KAAK,IACpCA,KAAK,CAACvB,IAAI,CAACC,QAAQ,CAAC,IAAI,CAAC,IACzBsB,KAAK,CAACrB,IAAI,CAACC,WAAW,CAAC,CAAC,CAACF,QAAQ,CAAC,SAAS,CAC7C,CAAC;IAED,IAAIoB,YAAY,EAAE;MAChB9B,OAAO,CAACK,GAAG,CAAC,4BAA4ByB,YAAY,CAACnB,IAAI,EAAE,CAAC;MAC5Dc,SAAS,CAACO,KAAK,GAAGF,YAAY;IAChC,CAAC,MAAM,IAAI3B,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;MAC5BJ,OAAO,CAACK,GAAG,CAAC,iDAAiDF,MAAM,CAAC,CAAC,CAAC,CAACQ,IAAI,EAAE,CAAC;MAC9Ec,SAAS,CAACO,KAAK,GAAG7B,MAAM,CAAC,CAAC,CAAC;IAC7B;;IAEA;IACAsB,SAAS,CAACQ,OAAO,GAAG,MAAM;MACxBjC,OAAO,CAACK,GAAG,CAAC,iCAAiC,CAAC;MAC9C,IAAIe,SAAS,EAAEA,SAAS,CAAC,CAAC;IAC5B,CAAC;IAEDK,SAAS,CAACS,KAAK,GAAG,MAAM;MACtBlC,OAAO,CAACK,GAAG,CAAC,mCAAmC,CAAC;MAChD,IAAIgB,OAAO,EAAEA,OAAO,CAAC,CAAC;IACxB,CAAC;IAEDI,SAAS,CAACU,OAAO,GAAIC,KAAK,IAAK;MAC7BpC,OAAO,CAACC,KAAK,CAAC,kCAAkC,EAAEmC,KAAK,CAAC;MACxD,IAAId,OAAO,EAAEA,OAAO,CAACc,KAAK,CAACnC,KAAK,IAAI,mBAAmB,CAAC;IAC1D,CAAC;;IAED;IACAJ,MAAM,CAACC,eAAe,CAACuC,KAAK,CAACZ,SAAS,CAAC;;IAEvC;;IAEA;IACA,MAAMa,cAAc,GAAGC,WAAW,CAAC,MAAM;MACvC,IAAI1C,MAAM,CAACC,eAAe,CAAC0C,QAAQ,EAAE;QACnCxC,OAAO,CAACK,GAAG,CAAC,oDAAoD,CAAC;QACjER,MAAM,CAACC,eAAe,CAAC2C,KAAK,CAAC,CAAC;QAC9B5C,MAAM,CAACC,eAAe,CAAC4C,MAAM,CAAC,CAAC;MACjC,CAAC,MAAM;QACLC,aAAa,CAACL,cAAc,CAAC;MAC/B;IACF,CAAC,EAAE,KAAK,CAAC;;IAET;IACA,MAAMM,eAAe,GAAGC,IAAI,CAACC,GAAG,CAAC,IAAI,EAAE3B,IAAI,CAACf,MAAM,GAAG,EAAE,CAAC,CAAC,CAAC;IAC1D,MAAM2C,SAAS,GAAGC,UAAU,CAAC,MAAM;MACjC,IAAInD,MAAM,CAACC,eAAe,CAAC0C,QAAQ,EAAE;QACnCxC,OAAO,CAACK,GAAG,CAAC,sDAAsDuC,eAAe,2BAA2B,CAAC;QAC7G/C,MAAM,CAACC,eAAe,CAAC0B,MAAM,CAAC,CAAC;QAC/B,IAAIH,OAAO,EAAEA,OAAO,CAAC,CAAC;MACxB;MACAsB,aAAa,CAACL,cAAc,CAAC;IAC/B,CAAC,EAAEM,eAAe,CAAC;;IAEnB;IACA,OAAO,MAAM;MACXK,YAAY,CAACF,SAAS,CAAC;MACvBJ,aAAa,CAACL,cAAc,CAAC;MAC7BzC,MAAM,CAACC,eAAe,CAAC0B,MAAM,CAAC,CAAC;IACjC,CAAC;EAEH,CAAC,CAAC,OAAOvB,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;IACpD,IAAIqB,OAAO,EAAEA,OAAO,CAACrB,KAAK,CAACiD,OAAO,IAAI,mBAAmB,CAAC;IAC1D,OAAO,MAAM,CAAC,CAAC;EACjB;AACF,CAAC;;AAED;AACA;AACA;;AAEA,MAAMC,YAAY,CAAC;EACjBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,WAAW,GAAG,OAAOzD,MAAM,KAAK,WAAW,KAC7C,yBAAyB,IAAIA,MAAM,IAAI,mBAAmB,IAAIA,MAAM,CAAC;IACxE,IAAI,CAAC0D,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACC,iBAAiB,GAAG,KAAK;IAC9B,IAAI,CAACC,kBAAkB,GAAG,IAAI;EAChC;;EAEA;AACF;AACA;AACA;EACEC,IAAIA,CAACC,QAAQ,GAAG,OAAO,EAAE;IACvB,IAAI,CAAC,IAAI,CAACT,WAAW,EAAE;MACrBtD,OAAO,CAACC,KAAK,CAAC,8DAA8D,CAAC;MAC7E,OAAO,KAAK;IACd;IAEA,MAAM+D,iBAAiB,GAAGnE,MAAM,CAACmE,iBAAiB,IAAInE,MAAM,CAACoE,uBAAuB;IACpF,IAAI,CAACZ,WAAW,GAAG,IAAIW,iBAAiB,CAAC,CAAC;;IAE1C;IACA,IAAI,CAACX,WAAW,CAAC5C,IAAI,GAAGsD,QAAQ;IAChC,IAAI,CAACV,WAAW,CAACa,UAAU,GAAG,KAAK;IACnC,IAAI,CAACb,WAAW,CAACc,cAAc,GAAG,IAAI;;IAEtC;IACA,IAAI,CAACd,WAAW,CAACe,QAAQ,GAAIhC,KAAK,IAAK;MACrC,MAAMoB,UAAU,GAAGa,KAAK,CAACC,IAAI,CAAClC,KAAK,CAACmC,OAAO,CAAC,CACzC1D,GAAG,CAAC2D,MAAM,IAAIA,MAAM,CAAC,CAAC,CAAC,CAAC,CACxB3D,GAAG,CAAC2D,MAAM,IAAIA,MAAM,CAAChB,UAAU,CAAC,CAChC1C,IAAI,CAAC,EAAE,CAAC;MAEX,IAAI,CAAC0C,UAAU,GAAGA,UAAU;MAE5B,IAAI,IAAI,CAACC,gBAAgB,EAAE;QACzB,IAAI,CAACA,gBAAgB,CAACD,UAAU,EAAEpB,KAAK,CAACmC,OAAO,CAAC,CAAC,CAAC,CAACE,OAAO,CAAC;MAC7D;IACF,CAAC;IAED,IAAI,CAACpB,WAAW,CAACnB,KAAK,GAAG,MAAM;MAC7B,IAAI,CAACqB,WAAW,GAAG,KAAK;MACxB,IAAI,IAAI,CAACG,aAAa,EAAE;QACtB,IAAI,CAACA,aAAa,CAAC,IAAI,CAACF,UAAU,CAAC;MACrC;IACF,CAAC;IAED,IAAI,CAACH,WAAW,CAAClB,OAAO,GAAIC,KAAK,IAAK;MACpC,IAAI,CAACmB,WAAW,GAAG,KAAK;MACxB,IAAI,IAAI,CAACI,eAAe,EAAE;QACxB,IAAI,CAACA,eAAe,CAACvB,KAAK,CAACnC,KAAK,CAAC;MACnC;IACF,CAAC;IAED,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;EACE,MAAMyE,2BAA2BA,CAAA,EAAG;IAClC,IAAIC,SAAS,CAACC,YAAY,IAAID,SAAS,CAACC,YAAY,CAACC,YAAY,EAAE;MACjE,IAAI;QACF;QACA,MAAMC,MAAM,GAAG,MAAMH,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;UAAEE,KAAK,EAAE;QAAK,CAAC,CAAC;QACzE;QACA,IAAI,CAACC,gBAAgB,GAAGF,MAAM;QAC9B,IAAI,CAAClB,iBAAiB,GAAG,IAAI;;QAE7B;QACA,IAAI,IAAI,CAACC,kBAAkB,EAAE;UAC3B,IAAI,CAACA,kBAAkB,CAAC,IAAI,CAAC;QAC/B;QAEA,OAAO,IAAI;MACb,CAAC,CAAC,OAAO5D,KAAK,EAAE;QACdD,OAAO,CAACC,KAAK,CAAC,+CAA+C,EAAEA,KAAK,CAAC;QAErE,IAAI,CAAC2D,iBAAiB,GAAG,KAAK;QAC9B;QACA,IAAI,IAAI,CAACC,kBAAkB,EAAE;UAC3B,IAAI,CAACA,kBAAkB,CAAC,KAAK,EAAE5D,KAAK,CAACiD,OAAO,CAAC;QAC/C;QAEA,OAAO,KAAK;MACd;IACF,CAAC,MAAM;MACLlD,OAAO,CAACC,KAAK,CAAC,kDAAkD,CAAC;MACjE,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;AACA;EACEgF,kBAAkBA,CAACC,QAAQ,EAAE;IAC3B,IAAI,CAACrB,kBAAkB,GAAGqB,QAAQ;EACpC;;EAEA;AACF;AACA;AACA;EACE,MAAMC,KAAKA,CAAA,EAAG;IACZ;IACA,IAAI,CAAC,IAAI,CAACvB,iBAAiB,EAAE;MAC3B,MAAMA,iBAAiB,GAAG,MAAM,IAAI,CAACc,2BAA2B,CAAC,CAAC;MAClE,IAAI,CAACd,iBAAiB,EAAE;QACtB,IAAI,IAAI,CAACD,eAAe,EAAE;UACxB,IAAI,CAACA,eAAe,CAAC,6CAA6C,CAAC;QACrE;QACA,OAAO,KAAK;MACd;IACF;IAEA,IAAI,CAAC,IAAI,CAACN,WAAW,EAAE;MACrB,MAAM+B,WAAW,GAAG,IAAI,CAACtB,IAAI,CAAC,CAAC;MAC/B,IAAI,CAACsB,WAAW,EAAE,OAAO,KAAK;IAChC;IAEA,IAAI;MACF,IAAI,CAAC/B,WAAW,CAAC8B,KAAK,CAAC,CAAC;MACxB,IAAI,CAAC5B,WAAW,GAAG,IAAI;MACvB,OAAO,IAAI;IACb,CAAC,CAAC,OAAOtD,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,4CAA4C,EAAEA,KAAK,CAAC;MAClE,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;EACEoF,IAAIA,CAAA,EAAG;IACL,IAAI,IAAI,CAAChC,WAAW,IAAI,IAAI,CAACE,WAAW,EAAE;MACxC,IAAI;QACF,IAAI,CAACF,WAAW,CAACgC,IAAI,CAAC,CAAC;QACvB,IAAI,CAAC9B,WAAW,GAAG,KAAK;;QAExB;QACA,IAAI,IAAI,CAACyB,gBAAgB,EAAE;UACzB,IAAI,CAACA,gBAAgB,CAACM,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACH,IAAI,CAAC,CAAC,CAAC;QAClE;QAEA,OAAO,IAAI;MACb,CAAC,CAAC,OAAOpF,KAAK,EAAE;QACdD,OAAO,CAACC,KAAK,CAAC,4CAA4C,EAAEA,KAAK,CAAC;QAClE,OAAO,KAAK;MACd;IACF;IACA,OAAO,KAAK;EACd;;EAEA;AACF;AACA;AACA;EACEwF,QAAQA,CAACP,QAAQ,EAAE;IACjB,IAAI,CAACzB,gBAAgB,GAAGyB,QAAQ;EAClC;;EAEA;AACF;AACA;AACA;EACEQ,KAAKA,CAACR,QAAQ,EAAE;IACd,IAAI,CAACxB,aAAa,GAAGwB,QAAQ;EAC/B;;EAEA;AACF;AACA;AACA;EACE5D,OAAOA,CAAC4D,QAAQ,EAAE;IAChB,IAAI,CAACvB,eAAe,GAAGuB,QAAQ;EACjC;;EAEA;AACF;AACA;AACA;EACES,oBAAoBA,CAAA,EAAG;IACrB,OAAO,IAAI,CAACrC,WAAW;EACzB;;EAEA;AACF;AACA;EACEvD,gBAAgBA,CAAA,EAAG;IACjB,OAAOA,gBAAgB,CAAC,CAAC;EAC3B;;EAEA;AACF;AACA;EACEmB,SAASA,CAACC,IAAI,EAAEC,SAAS,EAAEC,OAAO,EAAEC,OAAO,EAAE;IAC3C,OAAOJ,SAAS,CAACC,IAAI,EAAEC,SAAS,EAAEC,OAAO,EAAEC,OAAO,CAAC;EACrD;AACF;;AAEA;AACA,MAAMsE,YAAY,GAAG,IAAIzC,YAAY,CAAC,CAAC;AACvC,eAAeyC,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}