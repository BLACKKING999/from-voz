{"ast":null,"code":"/**\n * Utilidades para manejar la API de reconocimiento y síntesis de voz\n */\n\n// Función para precargar las voces del navegador\nlet voicesLoaded = false;\nlet availableVoices = [];\n\n// Cargar voces al inicializar\nconst loadVoices = () => {\n  return new Promise(resolve => {\n    if (voicesLoaded) {\n      resolve(availableVoices);\n      return;\n    }\n    const loadVoicesWhenAvailable = () => {\n      const voices = window.speechSynthesis.getVoices();\n      if (voices.length !== 0) {\n        availableVoices = voices;\n        voicesLoaded = true;\n        window.speechSynthesis.onvoiceschanged = null;\n        resolve(voices);\n      }\n    };\n    loadVoicesWhenAvailable();\n    if (window.speechSynthesis.onvoiceschanged !== undefined && !voicesLoaded) {\n      window.speechSynthesis.onvoiceschanged = loadVoicesWhenAvailable;\n    }\n  });\n};\n\n// Inicializar voces inmediatamente\nif (typeof window !== 'undefined' && 'speechSynthesis' in window) {\n  loadVoices();\n}\n\n// Verificar si SpeechRecognition está soportado\nexport const isSpeechRecognitionSupported = () => {\n  return 'SpeechRecognition' in window || 'webkitSpeechRecognition' in window;\n};\n\n// Verifica si el navegador soporta la API de síntesis de voz\nexport const isSpeechSynthesisSupported = () => {\n  return 'speechSynthesis' in window;\n};\n\n// Obtiene instancia de reconocimiento de voz\nexport const getSpeechRecognition = () => {\n  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n  if (!SpeechRecognition) {\n    throw new Error('El navegador no soporta reconocimiento de voz');\n  }\n  const recognition = new SpeechRecognition();\n  recognition.continuous = false;\n  recognition.lang = 'es-ES';\n  recognition.interimResults = false;\n  recognition.maxAlternatives = 1;\n  return recognition;\n};\n\n// Función para hablar texto\nexport const speakText = async (text, options = {}) => {\n  return new Promise(async (resolve, reject) => {\n    if (!('speechSynthesis' in window)) {\n      reject(new Error('El navegador no soporta síntesis de voz'));\n      return;\n    }\n\n    // Asegurar que las voces estén cargadas\n    const voices = await loadVoices();\n\n    // Cancelar cualquier habla en curso\n    window.speechSynthesis.cancel();\n    const utterance = new SpeechSynthesisUtterance(text);\n\n    // Seleccionar una voz en español si está disponible\n    const spanishVoice = voices.find(voice => voice.lang.includes('es') && voice.localService) || voices.find(voice => voice.lang.includes('es'));\n    if (spanishVoice) {\n      utterance.voice = spanishVoice;\n      console.log('Usando voz: ', spanishVoice.name);\n    } else {\n      console.log('No se encontró voz en español, usando voz predeterminada');\n    }\n\n    // Configurar opciones\n    utterance.lang = options.lang || 'es-ES';\n    utterance.rate = options.rate || 1;\n    utterance.pitch = options.pitch || 1;\n    utterance.volume = options.volume || 1;\n\n    // Eventos\n    utterance.onend = () => {\n      clearInterval(resumeSpeechInterval);\n      resolve();\n    };\n    utterance.onerror = error => {\n      clearInterval(resumeSpeechInterval);\n      reject(error);\n    };\n\n    // Hablar\n    console.log('Iniciando síntesis de voz: ', text);\n    window.speechSynthesis.speak(utterance);\n\n    // Parche para Chrome que a veces detiene la síntesis después de 15 segundos\n    const synth = window.speechSynthesis;\n    const resumeSpeechInterval = setInterval(() => {\n      if (!synth.speaking) {\n        clearInterval(resumeSpeechInterval);\n        return;\n      }\n      synth.pause();\n      synth.resume();\n    }, 10000);\n  });\n};\n\n// Función mejorada para escuchar el habla del usuario\nexport const listenForSpeech = (onResult, onError, onEnd, timeoutSeconds = 0) => {\n  if (!isSpeechRecognitionSupported()) {\n    if (onError) onError('SpeechRecognition no está soportado en este navegador');\n    return null;\n  }\n  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n  const recognition = new SpeechRecognition();\n\n  // Configurar el reconocimiento\n  recognition.lang = 'es-ES';\n  recognition.interimResults = false;\n  recognition.continuous = false;\n  recognition.maxAlternatives = 1;\n\n  // Manejar los resultados\n  recognition.onresult = event => {\n    const transcript = event.results[0][0].transcript;\n    const confidence = event.results[0][0].confidence;\n    console.log(`Reconocimiento exitoso: ${transcript} (Confianza: ${confidence})`);\n    if (onResult) {\n      onResult({\n        transcript: transcript,\n        confidence: confidence\n      });\n    }\n  };\n\n  // Manejar errores\n  recognition.onerror = event => {\n    console.log(`Error en reconocimiento: ${event.error}`);\n\n    // No reportar errores no-speech al usuario, solo internamente\n    if (event.error !== 'no-speech' && onError) {\n      onError(`Error de reconocimiento de voz: ${event.error}`);\n    }\n  };\n\n  // Cuando termina el reconocimiento\n  recognition.onend = () => {\n    console.log('onend - Reconocimiento finalizado');\n    if (onEnd) {\n      onEnd();\n    }\n  };\n\n  // Iniciar reconocimiento\n  try {\n    recognition.start();\n    console.log('Reconocimiento iniciado correctamente');\n\n    // Solo establecer timeout si es mayor que cero\n    let timeoutId = null;\n    if (timeoutSeconds > 0) {\n      timeoutId = setTimeout(() => {\n        console.log('Reconocimiento detenido por timeout');\n        try {\n          recognition.stop();\n        } catch (e) {\n          console.error('Error al detener reconocimiento:', e);\n        }\n      }, timeoutSeconds * 1000);\n    }\n    return {\n      stop: () => {\n        if (timeoutId) clearTimeout(timeoutId);\n        try {\n          recognition.stop();\n        } catch (e) {\n          console.error('Error al detener reconocimiento manualmente:', e);\n        }\n      }\n    };\n  } catch (error) {\n    console.error('Error al iniciar reconocimiento:', error);\n    if (onError) {\n      onError(`Error al iniciar reconocimiento: ${error.message}`);\n    }\n    return null;\n  }\n};\n\n// Procesa una respuesta de voz basada en el tipo de pregunta\nexport const processVoiceResponse = (response, questionType) => {\n  const text = response.toLowerCase().trim();\n  switch (questionType) {\n    case 'yesno':\n      if (text.includes('sí') || text.includes('si') || text.includes('claro') || text.includes('por supuesto') || text.includes('afirmativo')) {\n        return 'Sí';\n      } else if (text.includes('no') || text.includes('negativo') || text.includes('nunca') || text.includes('jamás')) {\n        return 'No';\n      } else {\n        return null; // Respuesta inválida\n      }\n    case 'rating':\n      // Buscar un número del 1 al 5 en la respuesta\n      const ratingMatch = text.match(/\\b([1-5])\\b/);\n      return ratingMatch ? ratingMatch[1] : null;\n    case 'single':\n    case 'multiple':\n    case 'open':\n    default:\n      return text;\n    // Devolver el texto tal cual para otros tipos\n  }\n};\n\n// Obtener las voces disponibles para la síntesis\nexport const getAvailableVoices = () => {\n  return new Promise(resolve => {\n    // Función para obtener voces\n    const getVoices = () => {\n      const voices = window.speechSynthesis.getVoices();\n      resolve(voices);\n    };\n\n    // Si las voces ya están disponibles, obtenerlas directamente\n    const voices = window.speechSynthesis.getVoices();\n    if (voices && voices.length > 0) {\n      resolve(voices);\n      return;\n    }\n\n    // Si no, esperar al evento voiceschanged\n    window.speechSynthesis.onvoiceschanged = getVoices;\n  });\n};\n\n// Verificar los permisos de micrófono\nexport const checkMicrophonePermission = async () => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    // Detener todas las pistas de audio para liberar el micrófono\n    stream.getTracks().forEach(track => track.stop());\n    return true;\n  } catch (error) {\n    console.error('Error al verificar permisos de micrófono:', error);\n    return false;\n  }\n};","map":{"version":3,"names":["voicesLoaded","availableVoices","loadVoices","Promise","resolve","loadVoicesWhenAvailable","voices","window","speechSynthesis","getVoices","length","onvoiceschanged","undefined","isSpeechRecognitionSupported","isSpeechSynthesisSupported","getSpeechRecognition","SpeechRecognition","webkitSpeechRecognition","Error","recognition","continuous","lang","interimResults","maxAlternatives","speakText","text","options","reject","cancel","utterance","SpeechSynthesisUtterance","spanishVoice","find","voice","includes","localService","console","log","name","rate","pitch","volume","onend","clearInterval","resumeSpeechInterval","onerror","error","speak","synth","setInterval","speaking","pause","resume","listenForSpeech","onResult","onError","onEnd","timeoutSeconds","onresult","event","transcript","results","confidence","start","timeoutId","setTimeout","stop","e","clearTimeout","message","processVoiceResponse","response","questionType","toLowerCase","trim","ratingMatch","match","getAvailableVoices","checkMicrophonePermission","stream","navigator","mediaDevices","getUserMedia","audio","getTracks","forEach","track"],"sources":["C:/Users/josep/Documents/Sistema de Encuestas por Voz/client/src/utils/voiceSurveyAPI.js"],"sourcesContent":["/**\n * Utilidades para manejar la API de reconocimiento y síntesis de voz\n */\n\n// Función para precargar las voces del navegador\nlet voicesLoaded = false;\nlet availableVoices = [];\n\n// Cargar voces al inicializar\nconst loadVoices = () => {\n  return new Promise((resolve) => {\n    if (voicesLoaded) {\n      resolve(availableVoices);\n      return;\n    }\n\n    const loadVoicesWhenAvailable = () => {\n      const voices = window.speechSynthesis.getVoices();\n      if (voices.length !== 0) {\n        availableVoices = voices;\n        voicesLoaded = true;\n        window.speechSynthesis.onvoiceschanged = null;\n        resolve(voices);\n      }\n    };\n\n    loadVoicesWhenAvailable();\n\n    if (window.speechSynthesis.onvoiceschanged !== undefined && !voicesLoaded) {\n      window.speechSynthesis.onvoiceschanged = loadVoicesWhenAvailable;\n    }\n  });\n};\n\n// Inicializar voces inmediatamente\nif (typeof window !== 'undefined' && 'speechSynthesis' in window) {\n  loadVoices();\n}\n\n// Verificar si SpeechRecognition está soportado\nexport const isSpeechRecognitionSupported = () => {\n  return 'SpeechRecognition' in window || 'webkitSpeechRecognition' in window;\n};\n\n// Verifica si el navegador soporta la API de síntesis de voz\nexport const isSpeechSynthesisSupported = () => {\n  return 'speechSynthesis' in window;\n};\n\n// Obtiene instancia de reconocimiento de voz\nexport const getSpeechRecognition = () => {\n  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n  if (!SpeechRecognition) {\n    throw new Error('El navegador no soporta reconocimiento de voz');\n  }\n  \n  const recognition = new SpeechRecognition();\n  recognition.continuous = false;\n  recognition.lang = 'es-ES';\n  recognition.interimResults = false;\n  recognition.maxAlternatives = 1;\n  \n  return recognition;\n};\n\n// Función para hablar texto\nexport const speakText = async (text, options = {}) => {\n  return new Promise(async (resolve, reject) => {\n    if (!('speechSynthesis' in window)) {\n      reject(new Error('El navegador no soporta síntesis de voz'));\n      return;\n    }\n\n    // Asegurar que las voces estén cargadas\n    const voices = await loadVoices();\n    \n    // Cancelar cualquier habla en curso\n    window.speechSynthesis.cancel();\n    \n    const utterance = new SpeechSynthesisUtterance(text);\n    \n    // Seleccionar una voz en español si está disponible\n    const spanishVoice = voices.find(voice => \n      voice.lang.includes('es') && voice.localService\n    ) || voices.find(voice => \n      voice.lang.includes('es')\n    );\n    \n    if (spanishVoice) {\n      utterance.voice = spanishVoice;\n      console.log('Usando voz: ', spanishVoice.name);\n    } else {\n      console.log('No se encontró voz en español, usando voz predeterminada');\n    }\n    \n    // Configurar opciones\n    utterance.lang = options.lang || 'es-ES';\n    utterance.rate = options.rate || 1;\n    utterance.pitch = options.pitch || 1;\n    utterance.volume = options.volume || 1;\n    \n    // Eventos\n    utterance.onend = () => {\n      clearInterval(resumeSpeechInterval);\n      resolve();\n    };\n    utterance.onerror = (error) => {\n      clearInterval(resumeSpeechInterval);\n      reject(error);\n    };\n    \n    // Hablar\n    console.log('Iniciando síntesis de voz: ', text);\n    window.speechSynthesis.speak(utterance);\n    \n    // Parche para Chrome que a veces detiene la síntesis después de 15 segundos\n    const synth = window.speechSynthesis;\n    const resumeSpeechInterval = setInterval(() => {\n      if (!synth.speaking) {\n        clearInterval(resumeSpeechInterval);\n        return;\n      }\n      synth.pause();\n      synth.resume();\n    }, 10000);\n  });\n};\n\n// Función mejorada para escuchar el habla del usuario\nexport const listenForSpeech = (onResult, onError, onEnd, timeoutSeconds = 0) => {\n  if (!isSpeechRecognitionSupported()) {\n    if (onError) onError('SpeechRecognition no está soportado en este navegador');\n    return null;\n  }\n\n  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n  const recognition = new SpeechRecognition();\n  \n  // Configurar el reconocimiento\n  recognition.lang = 'es-ES';\n  recognition.interimResults = false;\n  recognition.continuous = false;\n  recognition.maxAlternatives = 1;\n\n  // Manejar los resultados\n  recognition.onresult = (event) => {\n    const transcript = event.results[0][0].transcript;\n    const confidence = event.results[0][0].confidence;\n    \n    console.log(`Reconocimiento exitoso: ${transcript} (Confianza: ${confidence})`);\n    \n    if (onResult) {\n      onResult({\n        transcript: transcript,\n        confidence: confidence\n      });\n    }\n  };\n\n  // Manejar errores\n  recognition.onerror = (event) => {\n    console.log(`Error en reconocimiento: ${event.error}`);\n    \n    // No reportar errores no-speech al usuario, solo internamente\n    if (event.error !== 'no-speech' && onError) {\n      onError(`Error de reconocimiento de voz: ${event.error}`);\n    }\n  };\n\n  // Cuando termina el reconocimiento\n  recognition.onend = () => {\n    console.log('onend - Reconocimiento finalizado');\n    if (onEnd) {\n      onEnd();\n    }\n  };\n\n  // Iniciar reconocimiento\n  try {\n    recognition.start();\n    console.log('Reconocimiento iniciado correctamente');\n    \n    // Solo establecer timeout si es mayor que cero\n    let timeoutId = null;\n    if (timeoutSeconds > 0) {\n      timeoutId = setTimeout(() => {\n        console.log('Reconocimiento detenido por timeout');\n        try {\n          recognition.stop();\n        } catch (e) {\n          console.error('Error al detener reconocimiento:', e);\n        }\n      }, timeoutSeconds * 1000);\n    }\n    \n    return {\n      stop: () => {\n        if (timeoutId) clearTimeout(timeoutId);\n        try {\n          recognition.stop();\n        } catch (e) {\n          console.error('Error al detener reconocimiento manualmente:', e);\n        }\n      }\n    };\n  } catch (error) {\n    console.error('Error al iniciar reconocimiento:', error);\n    if (onError) {\n      onError(`Error al iniciar reconocimiento: ${error.message}`);\n    }\n    return null;\n  }\n};\n\n// Procesa una respuesta de voz basada en el tipo de pregunta\nexport const processVoiceResponse = (response, questionType) => {\n  const text = response.toLowerCase().trim();\n  \n  switch (questionType) {\n    case 'yesno':\n      if (text.includes('sí') || text.includes('si') || text.includes('claro') || \n          text.includes('por supuesto') || text.includes('afirmativo')) {\n        return 'Sí';\n      } else if (text.includes('no') || text.includes('negativo') || \n                text.includes('nunca') || text.includes('jamás')) {\n        return 'No';\n      } else {\n        return null; // Respuesta inválida\n      }\n    \n    case 'rating':\n      // Buscar un número del 1 al 5 en la respuesta\n      const ratingMatch = text.match(/\\b([1-5])\\b/);\n      return ratingMatch ? ratingMatch[1] : null;\n      \n    case 'single':\n    case 'multiple':\n    case 'open':\n    default:\n      return text; // Devolver el texto tal cual para otros tipos\n  }\n};\n\n// Obtener las voces disponibles para la síntesis\nexport const getAvailableVoices = () => {\n  return new Promise((resolve) => {\n    // Función para obtener voces\n    const getVoices = () => {\n      const voices = window.speechSynthesis.getVoices();\n      resolve(voices);\n    };\n\n    // Si las voces ya están disponibles, obtenerlas directamente\n    const voices = window.speechSynthesis.getVoices();\n    if (voices && voices.length > 0) {\n      resolve(voices);\n      return;\n    }\n\n    // Si no, esperar al evento voiceschanged\n    window.speechSynthesis.onvoiceschanged = getVoices;\n  });\n};\n\n// Verificar los permisos de micrófono\nexport const checkMicrophonePermission = async () => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    // Detener todas las pistas de audio para liberar el micrófono\n    stream.getTracks().forEach(track => track.stop());\n    return true;\n  } catch (error) {\n    console.error('Error al verificar permisos de micrófono:', error);\n    return false;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}