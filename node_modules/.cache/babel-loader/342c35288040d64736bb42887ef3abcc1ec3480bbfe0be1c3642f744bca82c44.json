{"ast":null,"code":"import nlp from 'compromise';\n\n/**\n * Servicio de procesamiento de lenguaje natural para mejorar las interacciones por voz\n * Utiliza compromise.js, una biblioteca ligera de NLP para el navegador\n */\n\n// Nota: No se importa el plugin para español porque no se encuentra disponible en la versión actual\n\n/**\n * Extraer nombre de una frase con procesamiento avanzado de lenguaje natural\n * @param {string} text - Texto del cual extraer el nombre\n * @returns {string} - Nombre extraído o valor por defecto\n */\nexport const extractName = text => {\n  if (!text || typeof text !== 'string') {\n    return 'Estimado participante';\n  }\n\n  // Procesar el texto con NLP\n  const doc = nlp(text);\n\n  // Verificar si es una pregunta\n  if (doc.questions().length > 0) {\n    console.log('NLP: Se detectó una pregunta en lugar de un nombre');\n    return null;\n  }\n\n  // Intentar extraer nombre propio (mejor precisión que regex)\n  const people = doc.people().out('array');\n  if (people.length > 0) {\n    console.log('NLP: Nombre extraído usando reconocimiento de entidades:', people[0]);\n    return people[0];\n  }\n\n  // Extraer frases de presentación\n  const presentationPhrases = ['me llamo', 'mi nombre es', 'soy', 'yo soy', 'puedes llamarme', 'puede llamarme', 'llámame', 'llamame'];\n  let cleanedText = text.trim();\n  for (const phrase of presentationPhrases) {\n    if (text.toLowerCase().includes(phrase)) {\n      // Extraer texto después de la frase\n      const parts = text.toLowerCase().split(phrase);\n      if (parts.length > 1 && parts[1].trim()) {\n        cleanedText = parts[1].trim();\n        break;\n      }\n    }\n  }\n\n  // Eliminar palabras comunes y saludos\n  const commonWords = ['gracias', 'por favor', 'hola', 'buenos días', 'buenas tardes', 'señor', 'señora'];\n  commonWords.forEach(word => {\n    cleanedText = cleanedText.replace(new RegExp(`\\\\b${word}\\\\b`, 'gi'), '');\n  });\n\n  // Eliminar múltiples espacios y puntuación\n  cleanedText = cleanedText.replace(/\\s+/g, ' ').trim();\n  cleanedText = cleanedText.replace(/[.,;:!?]/g, '').trim();\n  if (!cleanedText) {\n    return 'Estimado participante';\n  }\n\n  // Tomar las primeras palabras (máximo 3) como nombre\n  const words = cleanedText.split(' ');\n  const nameWords = words.slice(0, Math.min(3, words.length));\n\n  // Capitalizar cada palabra del nombre\n  return nameWords.map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\n};\n\n/**\n * Analiza el sentimiento de un texto (positivo, negativo, neutral)\n * @param {string} text - Texto a analizar\n * @returns {Object} - Objeto con el sentimiento y su intensidad\n */\nexport const analyzeSentiment = text => {\n  if (!text) return {\n    sentiment: 'neutral',\n    score: 0\n  };\n  const doc = nlp(text);\n  // compromise no tiene análisis de sentimiento incorporado\n  // utilizamos una versión simplificada basada en palabras positivas/negativas\n\n  const positiveWords = ['bueno', 'excelente', 'genial', 'perfecto', 'me gusta', 'sí', 'si', 'claro'];\n  const negativeWords = ['malo', 'terrible', 'horrible', 'pésimo', 'no me gusta', 'no', 'nunca'];\n  let positiveScore = 0;\n  let negativeScore = 0;\n  const lowerText = text.toLowerCase();\n  positiveWords.forEach(word => {\n    if (lowerText.includes(word)) positiveScore++;\n  });\n  negativeWords.forEach(word => {\n    if (lowerText.includes(word)) negativeScore++;\n  });\n  const score = (positiveScore - negativeScore) / 5; // Normalizar a un rango aproximado de -1 a 1\n\n  let sentiment = 'neutral';\n  if (score > 0.2) sentiment = 'positive';else if (score < -0.2) sentiment = 'negative';\n  return {\n    sentiment,\n    score\n  };\n};\n\n/**\n * Analiza una respuesta de texto para determinar si es afirmativa o negativa\n * @param {string} text - Texto a analizar\n * @returns {Object} - Resultado del análisis\n */\nconst analyzeYesNo = text => {\n  if (!text) return {\n    isYes: false,\n    isNo: false,\n    confidence: 0\n  };\n\n  // Palabras afirmativas en español\n  const yesWords = ['sí', 'si', 'claro', 'por supuesto', 'afirmativo', 'efectivamente', 'exacto', 'correcto', 'ok', 'vale', 'bueno', 'cierto'];\n\n  // Palabras negativas en español\n  const noWords = ['no', 'nunca', 'jamás', 'negativo', 'para nada', 'en absoluto', 'de ninguna manera', 'nada', 'tampoco'];\n\n  // Buscar coincidencias\n  let yesCount = 0;\n  let noCount = 0;\n  yesWords.forEach(word => {\n    if (text.toLowerCase().includes(word)) {\n      yesCount++;\n    }\n  });\n  noWords.forEach(word => {\n    if (text.toLowerCase().includes(word)) {\n      noCount++;\n    }\n  });\n\n  // Determinar resultado\n  const isYes = yesCount > 0 && yesCount > noCount;\n  const isNo = noCount > 0 && noCount >= yesCount;\n\n  // Calcular confianza (0-1)\n  let confidence = 0;\n  if (isYes) {\n    confidence = Math.min(yesCount / 3, 1);\n  } else if (isNo) {\n    confidence = Math.min(noCount / 3, 1);\n  }\n  return {\n    isYes,\n    isNo,\n    confidence\n  };\n};\n\n/**\n * Extrae números de un texto\n * @param {string} text - Texto a analizar\n * @returns {Array} - Lista de números encontrados\n */\nconst extractNumbers = text => {\n  if (!text) return [];\n  const doc = nlp(text);\n  const numbers = doc.numbers().out('array');\n\n  // Intentar extraer números como dígitos\n  const digitMatches = text.match(/\\d+/g) || [];\n\n  // Combinar resultados y eliminar duplicados\n  const allNumbers = [...numbers, ...digitMatches];\n  const uniqueNumbers = [...new Set(allNumbers)];\n  return uniqueNumbers.map(num => {\n    // Intentar convertir a número\n    const parsed = parseFloat(num);\n    return isNaN(parsed) ? num : parsed;\n  });\n};\n\n/**\n * Determina la opción más probable de una lista basada en la respuesta\n * @param {string} text - Texto de respuesta\n * @param {Array} options - Lista de opciones\n * @returns {Object} - Opción seleccionada y nivel de confianza\n */\nconst findBestMatchingOption = (text, options) => {\n  if (!text || !options || options.length === 0) {\n    return {\n      selected: null,\n      confidence: 0\n    };\n  }\n  const normalizedText = text.toLowerCase();\n\n  // Buscar coincidencias exactas primero (por número o texto completo)\n  const numbers = extractNumbers(normalizedText);\n\n  // Si hay un número que corresponde a un índice válido\n  if (numbers.length > 0) {\n    const index = numbers[0] - 1; // Restar 1 porque los usuarios suelen contar desde 1\n    if (index >= 0 && index < options.length) {\n      return {\n        selected: options[index],\n        confidence: 0.9\n      };\n    }\n  }\n\n  // Buscar por texto\n  let bestMatch = null;\n  let highestConfidence = 0;\n  options.forEach(option => {\n    const optionText = option.toLowerCase();\n\n    // Calcular similitud simple basada en inclusión\n    if (normalizedText.includes(optionText)) {\n      const confidence = optionText.length / normalizedText.length;\n      if (confidence > highestConfidence) {\n        highestConfidence = confidence;\n        bestMatch = option;\n      }\n    } else if (optionText.includes(normalizedText)) {\n      const confidence = normalizedText.length / optionText.length * 0.8; // Penalización\n      if (confidence > highestConfidence) {\n        highestConfidence = confidence;\n        bestMatch = option;\n      }\n    }\n  });\n  return {\n    selected: bestMatch,\n    confidence: highestConfidence\n  };\n};\n\n/**\n * Analiza la intención del usuario a partir de su respuesta\n * @param {string} text - Texto de entrada\n * @returns {Object} - Objeto con la intención detectada y confianza\n */\nexport const analyzeIntent = text => {\n  if (!text) return {\n    intent: 'unknown',\n    confidence: 0\n  };\n  const doc = nlp(text);\n\n  // Detectar si es una pregunta\n  if (doc.questions().length > 0) {\n    return {\n      intent: 'question',\n      confidence: 0.9\n    };\n  }\n\n  // Detectar afirmación/negación\n  const affirmations = ['sí', 'si', 'claro', 'por supuesto', 'afirmativo', 'correcto', 'exacto'];\n  const negations = ['no', 'nope', 'negativo', 'para nada', 'en absoluto', 'nunca'];\n  const lowerText = text.toLowerCase();\n  for (const word of affirmations) {\n    if (lowerText.includes(word)) {\n      return {\n        intent: 'affirmation',\n        confidence: 0.85\n      };\n    }\n  }\n  for (const word of negations) {\n    if (lowerText.includes(word)) {\n      return {\n        intent: 'negation',\n        confidence: 0.85\n      };\n    }\n  }\n\n  // Detectar números (para preguntas de calificación)\n  const numbers = doc.numbers().out('array');\n  if (numbers.length > 0) {\n    return {\n      intent: 'number',\n      value: numbers[0],\n      confidence: 0.9\n    };\n  }\n  return {\n    intent: 'statement',\n    confidence: 0.5\n  };\n};\n\n/**\n * Procesa la respuesta para una pregunta según su tipo\n * @param {string} text - Respuesta del usuario\n * @param {string} questionType - Tipo de pregunta ('yesno', 'rating', 'text')\n * @returns {*} - Respuesta procesada (boolean, number o string)\n */\nexport const processResponse = (text, questionType) => {\n  if (!text) return null;\n  const intent = analyzeIntent(text);\n  console.log('NLP: Intención detectada:', intent);\n  switch (questionType) {\n    case 'yesno':\n      if (intent.intent === 'affirmation') return true;\n      if (intent.intent === 'negation') return false;\n      // Analizar el texto para encontrar afirmación/negación más compleja\n      const yesNoResult = analyzeYesNo(text);\n      return yesNoResult.isYes;\n    case 'rating':\n      if (intent.intent === 'number' && intent.value >= 1 && intent.value <= 5) {\n        return intent.value;\n      }\n      // Extraer número del texto\n      const numbers = extractNumbers(text);\n      if (numbers.length > 0) {\n        let num = parseInt(numbers[0]);\n        // Limitar al rango 1-5\n        return Math.max(1, Math.min(5, num));\n      }\n      return null;\n    case 'text':\n    default:\n      // Limpiar el texto para obtener la respuesta más relevante\n      return text.trim();\n  }\n};\n\n/**\n * Genera una respuesta personalizada basada en el sentimiento del usuario\n * @param {string} userText - Texto del usuario\n * @param {Array} possibleResponses - Array de posibles respuestas\n * @returns {string} - Respuesta seleccionada\n */\nexport const generateAdaptiveResponse = (userText, possibleResponses) => {\n  const sentiment = analyzeSentiment(userText);\n\n  // Clasificar respuestas según el sentimiento\n  const positiveResponses = possibleResponses.filter(r => r.tone === 'positive');\n  const neutralResponses = possibleResponses.filter(r => r.tone === 'neutral');\n  const negativeResponses = possibleResponses.filter(r => r.tone === 'supportive');\n\n  // Seleccionar respuesta apropiada según el sentimiento del usuario\n  let selectedResponses;\n  if (sentiment.sentiment === 'positive') {\n    selectedResponses = positiveResponses.length ? positiveResponses : neutralResponses;\n  } else if (sentiment.sentiment === 'negative') {\n    selectedResponses = negativeResponses.length ? negativeResponses : neutralResponses;\n  } else {\n    selectedResponses = neutralResponses.length ? neutralResponses : positiveResponses;\n  }\n\n  // Si no hay respuestas del tipo adecuado, usar cualquiera\n  if (!selectedResponses.length) {\n    selectedResponses = possibleResponses;\n  }\n\n  // Elegir aleatoriamente entre las respuestas apropiadas\n  const randomIndex = Math.floor(Math.random() * selectedResponses.length);\n  return selectedResponses[randomIndex].text;\n};\nexport default {\n  extractName,\n  analyzeIntent,\n  processResponse,\n  analyzeSentiment,\n  generateAdaptiveResponse,\n  analyzeYesNo,\n  extractNumbers,\n  findBestMatchingOption\n};","map":{"version":3,"names":["nlp","extractName","text","doc","questions","length","console","log","people","out","presentationPhrases","cleanedText","trim","phrase","toLowerCase","includes","parts","split","commonWords","forEach","word","replace","RegExp","words","nameWords","slice","Math","min","map","charAt","toUpperCase","join","analyzeSentiment","sentiment","score","positiveWords","negativeWords","positiveScore","negativeScore","lowerText","analyzeYesNo","isYes","isNo","confidence","yesWords","noWords","yesCount","noCount","extractNumbers","numbers","digitMatches","match","allNumbers","uniqueNumbers","Set","num","parsed","parseFloat","isNaN","findBestMatchingOption","options","selected","normalizedText","index","bestMatch","highestConfidence","option","optionText","analyzeIntent","intent","affirmations","negations","value","processResponse","questionType","yesNoResult","parseInt","max","generateAdaptiveResponse","userText","possibleResponses","positiveResponses","filter","r","tone","neutralResponses","negativeResponses","selectedResponses","randomIndex","floor","random"],"sources":["C:/Users/josep/Documents/Sistema de Encuestas por Voz/client/src/services/nlpService.js"],"sourcesContent":["import nlp from 'compromise';\n\n/**\n * Servicio de procesamiento de lenguaje natural para mejorar las interacciones por voz\n * Utiliza compromise.js, una biblioteca ligera de NLP para el navegador\n */\n\n// Nota: No se importa el plugin para español porque no se encuentra disponible en la versión actual\n\n/**\n * Extraer nombre de una frase con procesamiento avanzado de lenguaje natural\n * @param {string} text - Texto del cual extraer el nombre\n * @returns {string} - Nombre extraído o valor por defecto\n */\nexport const extractName = (text) => {\n  if (!text || typeof text !== 'string') {\n    return 'Estimado participante';\n  }\n\n  // Procesar el texto con NLP\n  const doc = nlp(text);\n  \n  // Verificar si es una pregunta\n  if (doc.questions().length > 0) {\n    console.log('NLP: Se detectó una pregunta en lugar de un nombre');\n    return null;\n  }\n  \n  // Intentar extraer nombre propio (mejor precisión que regex)\n  const people = doc.people().out('array');\n  if (people.length > 0) {\n    console.log('NLP: Nombre extraído usando reconocimiento de entidades:', people[0]);\n    return people[0];\n  }\n  \n  // Extraer frases de presentación\n  const presentationPhrases = ['me llamo', 'mi nombre es', 'soy', 'yo soy', \n    'puedes llamarme', 'puede llamarme', 'llámame', 'llamame'];\n  \n  let cleanedText = text.trim();\n  for (const phrase of presentationPhrases) {\n    if (text.toLowerCase().includes(phrase)) {\n      // Extraer texto después de la frase\n      const parts = text.toLowerCase().split(phrase);\n      if (parts.length > 1 && parts[1].trim()) {\n        cleanedText = parts[1].trim();\n        break;\n      }\n    }\n  }\n  \n  // Eliminar palabras comunes y saludos\n  const commonWords = ['gracias', 'por favor', 'hola', 'buenos días', 'buenas tardes', 'señor', 'señora'];\n  commonWords.forEach(word => {\n    cleanedText = cleanedText.replace(new RegExp(`\\\\b${word}\\\\b`, 'gi'), '');\n  });\n  \n  // Eliminar múltiples espacios y puntuación\n  cleanedText = cleanedText.replace(/\\s+/g, ' ').trim();\n  cleanedText = cleanedText.replace(/[.,;:!?]/g, '').trim();\n  \n  if (!cleanedText) {\n    return 'Estimado participante';\n  }\n  \n  // Tomar las primeras palabras (máximo 3) como nombre\n  const words = cleanedText.split(' ');\n  const nameWords = words.slice(0, Math.min(3, words.length));\n  \n  // Capitalizar cada palabra del nombre\n  return nameWords\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join(' ');\n};\n\n/**\n * Analiza el sentimiento de un texto (positivo, negativo, neutral)\n * @param {string} text - Texto a analizar\n * @returns {Object} - Objeto con el sentimiento y su intensidad\n */\nexport const analyzeSentiment = (text) => {\n  if (!text) return { sentiment: 'neutral', score: 0 };\n  \n  const doc = nlp(text);\n  // compromise no tiene análisis de sentimiento incorporado\n  // utilizamos una versión simplificada basada en palabras positivas/negativas\n  \n  const positiveWords = ['bueno', 'excelente', 'genial', 'perfecto', 'me gusta', 'sí', 'si', 'claro'];\n  const negativeWords = ['malo', 'terrible', 'horrible', 'pésimo', 'no me gusta', 'no', 'nunca'];\n  \n  let positiveScore = 0;\n  let negativeScore = 0;\n  \n  const lowerText = text.toLowerCase();\n  \n  positiveWords.forEach(word => {\n    if (lowerText.includes(word)) positiveScore++;\n  });\n  \n  negativeWords.forEach(word => {\n    if (lowerText.includes(word)) negativeScore++;\n  });\n  \n  const score = (positiveScore - negativeScore) / 5; // Normalizar a un rango aproximado de -1 a 1\n  \n  let sentiment = 'neutral';\n  if (score > 0.2) sentiment = 'positive';\n  else if (score < -0.2) sentiment = 'negative';\n  \n  return { sentiment, score };\n};\n\n/**\n * Analiza una respuesta de texto para determinar si es afirmativa o negativa\n * @param {string} text - Texto a analizar\n * @returns {Object} - Resultado del análisis\n */\nconst analyzeYesNo = (text) => {\n  if (!text) return { isYes: false, isNo: false, confidence: 0 };\n  \n  // Palabras afirmativas en español\n  const yesWords = ['sí', 'si', 'claro', 'por supuesto', 'afirmativo', 'efectivamente', \n                   'exacto', 'correcto', 'ok', 'vale', 'bueno', 'cierto'];\n  \n  // Palabras negativas en español\n  const noWords = ['no', 'nunca', 'jamás', 'negativo', 'para nada', 'en absoluto', \n                  'de ninguna manera', 'nada', 'tampoco'];\n  \n  // Buscar coincidencias\n  let yesCount = 0;\n  let noCount = 0;\n  \n  yesWords.forEach(word => {\n    if (text.toLowerCase().includes(word)) {\n      yesCount++;\n    }\n  });\n  \n  noWords.forEach(word => {\n    if (text.toLowerCase().includes(word)) {\n      noCount++;\n    }\n  });\n  \n  // Determinar resultado\n  const isYes = yesCount > 0 && yesCount > noCount;\n  const isNo = noCount > 0 && noCount >= yesCount;\n  \n  // Calcular confianza (0-1)\n  let confidence = 0;\n  if (isYes) {\n    confidence = Math.min(yesCount / 3, 1);\n  } else if (isNo) {\n    confidence = Math.min(noCount / 3, 1);\n  }\n  \n  return { isYes, isNo, confidence };\n};\n\n/**\n * Extrae números de un texto\n * @param {string} text - Texto a analizar\n * @returns {Array} - Lista de números encontrados\n */\nconst extractNumbers = (text) => {\n  if (!text) return [];\n  \n  const doc = nlp(text);\n  const numbers = doc.numbers().out('array');\n  \n  // Intentar extraer números como dígitos\n  const digitMatches = text.match(/\\d+/g) || [];\n  \n  // Combinar resultados y eliminar duplicados\n  const allNumbers = [...numbers, ...digitMatches];\n  const uniqueNumbers = [...new Set(allNumbers)];\n  \n  return uniqueNumbers.map(num => {\n    // Intentar convertir a número\n    const parsed = parseFloat(num);\n    return isNaN(parsed) ? num : parsed;\n  });\n};\n\n/**\n * Determina la opción más probable de una lista basada en la respuesta\n * @param {string} text - Texto de respuesta\n * @param {Array} options - Lista de opciones\n * @returns {Object} - Opción seleccionada y nivel de confianza\n */\nconst findBestMatchingOption = (text, options) => {\n  if (!text || !options || options.length === 0) {\n    return { selected: null, confidence: 0 };\n  }\n  \n  const normalizedText = text.toLowerCase();\n  \n  // Buscar coincidencias exactas primero (por número o texto completo)\n  const numbers = extractNumbers(normalizedText);\n  \n  // Si hay un número que corresponde a un índice válido\n  if (numbers.length > 0) {\n    const index = numbers[0] - 1; // Restar 1 porque los usuarios suelen contar desde 1\n    if (index >= 0 && index < options.length) {\n      return { selected: options[index], confidence: 0.9 };\n    }\n  }\n  \n  // Buscar por texto\n  let bestMatch = null;\n  let highestConfidence = 0;\n  \n  options.forEach(option => {\n    const optionText = option.toLowerCase();\n    \n    // Calcular similitud simple basada en inclusión\n    if (normalizedText.includes(optionText)) {\n      const confidence = optionText.length / normalizedText.length;\n      if (confidence > highestConfidence) {\n        highestConfidence = confidence;\n        bestMatch = option;\n      }\n    } else if (optionText.includes(normalizedText)) {\n      const confidence = normalizedText.length / optionText.length * 0.8; // Penalización\n      if (confidence > highestConfidence) {\n        highestConfidence = confidence;\n        bestMatch = option;\n      }\n    }\n  });\n  \n  return { selected: bestMatch, confidence: highestConfidence };\n};\n\n/**\n * Analiza la intención del usuario a partir de su respuesta\n * @param {string} text - Texto de entrada\n * @returns {Object} - Objeto con la intención detectada y confianza\n */\nexport const analyzeIntent = (text) => {\n  if (!text) return { intent: 'unknown', confidence: 0 };\n  \n  const doc = nlp(text);\n  \n  // Detectar si es una pregunta\n  if (doc.questions().length > 0) {\n    return { intent: 'question', confidence: 0.9 };\n  }\n  \n  // Detectar afirmación/negación\n  const affirmations = ['sí', 'si', 'claro', 'por supuesto', 'afirmativo', 'correcto', 'exacto'];\n  const negations = ['no', 'nope', 'negativo', 'para nada', 'en absoluto', 'nunca'];\n  \n  const lowerText = text.toLowerCase();\n  \n  for (const word of affirmations) {\n    if (lowerText.includes(word)) {\n      return { intent: 'affirmation', confidence: 0.85 };\n    }\n  }\n  \n  for (const word of negations) {\n    if (lowerText.includes(word)) {\n      return { intent: 'negation', confidence: 0.85 };\n    }\n  }\n  \n  // Detectar números (para preguntas de calificación)\n  const numbers = doc.numbers().out('array');\n  if (numbers.length > 0) {\n    return { intent: 'number', value: numbers[0], confidence: 0.9 };\n  }\n  \n  return { intent: 'statement', confidence: 0.5 };\n};\n\n/**\n * Procesa la respuesta para una pregunta según su tipo\n * @param {string} text - Respuesta del usuario\n * @param {string} questionType - Tipo de pregunta ('yesno', 'rating', 'text')\n * @returns {*} - Respuesta procesada (boolean, number o string)\n */\nexport const processResponse = (text, questionType) => {\n  if (!text) return null;\n  \n  const intent = analyzeIntent(text);\n  console.log('NLP: Intención detectada:', intent);\n  \n  switch (questionType) {\n    case 'yesno':\n      if (intent.intent === 'affirmation') return true;\n      if (intent.intent === 'negation') return false;\n      // Analizar el texto para encontrar afirmación/negación más compleja\n      const yesNoResult = analyzeYesNo(text);\n      return yesNoResult.isYes;\n      \n    case 'rating':\n      if (intent.intent === 'number' && intent.value >= 1 && intent.value <= 5) {\n        return intent.value;\n      }\n      // Extraer número del texto\n      const numbers = extractNumbers(text);\n      if (numbers.length > 0) {\n        let num = parseInt(numbers[0]);\n        // Limitar al rango 1-5\n        return Math.max(1, Math.min(5, num));\n      }\n      return null;\n      \n    case 'text':\n    default:\n      // Limpiar el texto para obtener la respuesta más relevante\n      return text.trim();\n  }\n};\n\n/**\n * Genera una respuesta personalizada basada en el sentimiento del usuario\n * @param {string} userText - Texto del usuario\n * @param {Array} possibleResponses - Array de posibles respuestas\n * @returns {string} - Respuesta seleccionada\n */\nexport const generateAdaptiveResponse = (userText, possibleResponses) => {\n  const sentiment = analyzeSentiment(userText);\n  \n  // Clasificar respuestas según el sentimiento\n  const positiveResponses = possibleResponses.filter(r => r.tone === 'positive');\n  const neutralResponses = possibleResponses.filter(r => r.tone === 'neutral');\n  const negativeResponses = possibleResponses.filter(r => r.tone === 'supportive');\n  \n  // Seleccionar respuesta apropiada según el sentimiento del usuario\n  let selectedResponses;\n  if (sentiment.sentiment === 'positive') {\n    selectedResponses = positiveResponses.length ? positiveResponses : neutralResponses;\n  } else if (sentiment.sentiment === 'negative') {\n    selectedResponses = negativeResponses.length ? negativeResponses : neutralResponses;\n  } else {\n    selectedResponses = neutralResponses.length ? neutralResponses : positiveResponses;\n  }\n  \n  // Si no hay respuestas del tipo adecuado, usar cualquiera\n  if (!selectedResponses.length) {\n    selectedResponses = possibleResponses;\n  }\n  \n  // Elegir aleatoriamente entre las respuestas apropiadas\n  const randomIndex = Math.floor(Math.random() * selectedResponses.length);\n  return selectedResponses[randomIndex].text;\n};\n\nexport default {\n  extractName,\n  analyzeIntent,\n  processResponse,\n  analyzeSentiment,\n  generateAdaptiveResponse,\n  analyzeYesNo,\n  extractNumbers,\n  findBestMatchingOption\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}