{"ast":null,"code":"import nlp from 'compromise';\nimport nlpEs from 'compromise/plugins/es';\n\n/**\n * Servicio de procesamiento de lenguaje natural para mejorar las interacciones por voz\n * Utiliza compromise.js, una biblioteca ligera de NLP para el navegador\n */\n\n// Registrar el plugin para español\nnlp.plugin(nlpEs);\n\n/**\n * Extraer nombre de una frase con procesamiento avanzado de lenguaje natural\n * @param {string} text - Texto del cual extraer el nombre\n * @returns {string} - Nombre extraído o valor por defecto\n */\nexport const extractName = text => {\n  if (!text || typeof text !== 'string') {\n    return 'Estimado participante';\n  }\n\n  // Procesar el texto con NLP\n  const doc = nlp(text);\n\n  // Verificar si es una pregunta\n  if (doc.questions().length > 0) {\n    console.log('NLP: Se detectó una pregunta en lugar de un nombre');\n    return null;\n  }\n\n  // Intentar extraer nombre propio (mejor precisión que regex)\n  const people = doc.people().out('array');\n  if (people.length > 0) {\n    console.log('NLP: Nombre extraído usando reconocimiento de entidades:', people[0]);\n    return people[0];\n  }\n\n  // Extraer frases de presentación\n  const presentationPhrases = ['me llamo', 'mi nombre es', 'soy', 'yo soy', 'puedes llamarme', 'puede llamarme', 'llámame', 'llamame'];\n  let cleanedText = text.trim();\n  for (const phrase of presentationPhrases) {\n    if (text.toLowerCase().includes(phrase)) {\n      // Extraer texto después de la frase\n      const parts = text.toLowerCase().split(phrase);\n      if (parts.length > 1 && parts[1].trim()) {\n        cleanedText = parts[1].trim();\n        break;\n      }\n    }\n  }\n\n  // Eliminar palabras comunes y saludos\n  const commonWords = ['gracias', 'por favor', 'hola', 'buenos días', 'buenas tardes', 'señor', 'señora'];\n  commonWords.forEach(word => {\n    cleanedText = cleanedText.replace(new RegExp(`\\\\b${word}\\\\b`, 'gi'), '');\n  });\n\n  // Eliminar múltiples espacios y puntuación\n  cleanedText = cleanedText.replace(/\\s+/g, ' ').trim();\n  cleanedText = cleanedText.replace(/[.,;:!?]/g, '').trim();\n  if (!cleanedText) {\n    return 'Estimado participante';\n  }\n\n  // Tomar las primeras palabras (máximo 3) como nombre\n  const words = cleanedText.split(' ');\n  const nameWords = words.slice(0, Math.min(3, words.length));\n\n  // Capitalizar cada palabra del nombre\n  return nameWords.map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\n};\n\n/**\n * Analiza la intención del usuario a partir de su respuesta\n * @param {string} text - Texto de entrada\n * @returns {Object} - Objeto con la intención detectada y confianza\n */\nexport const analyzeIntent = text => {\n  if (!text) return {\n    intent: 'unknown',\n    confidence: 0\n  };\n  const doc = nlp(text);\n\n  // Detectar si es una pregunta\n  if (doc.questions().length > 0) {\n    return {\n      intent: 'question',\n      confidence: 0.9\n    };\n  }\n\n  // Detectar afirmación/negación\n  const affirmations = ['sí', 'si', 'claro', 'por supuesto', 'afirmativo', 'correcto', 'exacto'];\n  const negations = ['no', 'nope', 'negativo', 'para nada', 'en absoluto', 'nunca'];\n  const lowerText = text.toLowerCase();\n  for (const word of affirmations) {\n    if (lowerText.includes(word)) {\n      return {\n        intent: 'affirmation',\n        confidence: 0.85\n      };\n    }\n  }\n  for (const word of negations) {\n    if (lowerText.includes(word)) {\n      return {\n        intent: 'negation',\n        confidence: 0.85\n      };\n    }\n  }\n\n  // Detectar números (para preguntas de calificación)\n  const numbers = doc.numbers().out('array');\n  if (numbers.length > 0) {\n    return {\n      intent: 'number',\n      value: numbers[0],\n      confidence: 0.9\n    };\n  }\n  return {\n    intent: 'statement',\n    confidence: 0.5\n  };\n};\n\n/**\n * Procesa la respuesta para una pregunta según su tipo\n * @param {string} text - Respuesta del usuario\n * @param {string} questionType - Tipo de pregunta ('yesno', 'rating', 'text')\n * @returns {*} - Respuesta procesada (boolean, number o string)\n */\nexport const processResponse = (text, questionType) => {\n  if (!text) return null;\n  const intent = analyzeIntent(text);\n  console.log('NLP: Intención detectada:', intent);\n  switch (questionType) {\n    case 'yesno':\n      if (intent.intent === 'affirmation') return true;\n      if (intent.intent === 'negation') return false;\n      // Analizar el texto para encontrar afirmación/negación más compleja\n      const isPositive = nlp(text).sentiment() > 0;\n      return isPositive;\n    case 'rating':\n      if (intent.intent === 'number' && intent.value >= 1 && intent.value <= 5) {\n        return intent.value;\n      }\n      // Extraer número del texto\n      const numbers = nlp(text).numbers().out('array');\n      if (numbers.length > 0) {\n        let num = parseInt(numbers[0]);\n        // Limitar al rango 1-5\n        return Math.max(1, Math.min(5, num));\n      }\n      return null;\n    case 'text':\n    default:\n      // Limpiar el texto para obtener la respuesta más relevante\n      const doc = nlp(text);\n      // Eliminar muletillas comunes\n      return doc.out('text');\n  }\n};\n\n/**\n * Analiza el sentimiento de un texto (positivo, negativo, neutral)\n * @param {string} text - Texto a analizar\n * @returns {Object} - Objeto con el sentimiento y su intensidad\n */\nexport const analyzeSentiment = text => {\n  if (!text) return {\n    sentiment: 'neutral',\n    score: 0\n  };\n  const doc = nlp(text);\n  const score = doc.sentiment();\n  let sentiment = 'neutral';\n  if (score > 0.2) sentiment = 'positive';else if (score < -0.2) sentiment = 'negative';\n  return {\n    sentiment,\n    score\n  };\n};\n\n/**\n * Genera una respuesta personalizada basada en el sentimiento del usuario\n * @param {string} userText - Texto del usuario\n * @param {Array} possibleResponses - Array de posibles respuestas\n * @returns {string} - Respuesta seleccionada\n */\nexport const generateAdaptiveResponse = (userText, possibleResponses) => {\n  const sentiment = analyzeSentiment(userText);\n\n  // Clasificar respuestas según el sentimiento\n  const positiveResponses = possibleResponses.filter(r => r.tone === 'positive');\n  const neutralResponses = possibleResponses.filter(r => r.tone === 'neutral');\n  const negativeResponses = possibleResponses.filter(r => r.tone === 'supportive');\n\n  // Seleccionar respuesta apropiada según el sentimiento del usuario\n  let selectedResponses;\n  if (sentiment.sentiment === 'positive') {\n    selectedResponses = positiveResponses.length ? positiveResponses : neutralResponses;\n  } else if (sentiment.sentiment === 'negative') {\n    selectedResponses = negativeResponses.length ? negativeResponses : neutralResponses;\n  } else {\n    selectedResponses = neutralResponses.length ? neutralResponses : positiveResponses;\n  }\n\n  // Si no hay respuestas del tipo adecuado, usar cualquiera\n  if (!selectedResponses.length) {\n    selectedResponses = possibleResponses;\n  }\n\n  // Elegir aleatoriamente entre las respuestas apropiadas\n  const randomIndex = Math.floor(Math.random() * selectedResponses.length);\n  return selectedResponses[randomIndex].text;\n};\n\n/**\n * Analiza una respuesta de texto para determinar si es afirmativa o negativa\n * @param {string} text - Texto a analizar\n * @returns {Object} - Resultado del análisis\n */\nconst analyzeYesNo = text => {\n  if (!text) return {\n    isYes: false,\n    isNo: false,\n    confidence: 0\n  };\n  const doc = nlp(text.toLowerCase());\n\n  // Palabras afirmativas en español\n  const yesWords = ['sí', 'si', 'claro', 'por supuesto', 'afirmativo', 'efectivamente', 'exacto', 'correcto', 'ok', 'vale', 'bueno', 'cierto'];\n\n  // Palabras negativas en español\n  const noWords = ['no', 'nunca', 'jamás', 'negativo', 'para nada', 'en absoluto', 'de ninguna manera', 'nada', 'tampoco'];\n\n  // Buscar coincidencias\n  let yesCount = 0;\n  let noCount = 0;\n  yesWords.forEach(word => {\n    if (text.toLowerCase().includes(word)) {\n      yesCount++;\n    }\n  });\n  noWords.forEach(word => {\n    if (text.toLowerCase().includes(word)) {\n      noCount++;\n    }\n  });\n\n  // Determinar resultado\n  const isYes = yesCount > 0 && yesCount > noCount;\n  const isNo = noCount > 0 && noCount >= yesCount;\n\n  // Calcular confianza (0-1)\n  let confidence = 0;\n  if (isYes) {\n    confidence = Math.min(yesCount / 3, 1);\n  } else if (isNo) {\n    confidence = Math.min(noCount / 3, 1);\n  }\n  return {\n    isYes,\n    isNo,\n    confidence\n  };\n};\n\n/**\n * Extrae números de un texto\n * @param {string} text - Texto a analizar\n * @returns {Array} - Lista de números encontrados\n */\nconst extractNumbers = text => {\n  if (!text) return [];\n  const doc = nlp(text);\n  const numbers = doc.numbers().out('array');\n\n  // Intentar extraer números como dígitos\n  const digitMatches = text.match(/\\d+/g) || [];\n\n  // Combinar resultados y eliminar duplicados\n  const allNumbers = [...numbers, ...digitMatches];\n  const uniqueNumbers = [...new Set(allNumbers)];\n  return uniqueNumbers.map(num => {\n    // Intentar convertir a número\n    const parsed = parseFloat(num);\n    return isNaN(parsed) ? num : parsed;\n  });\n};\n\n/**\n * Determina la opción más probable de una lista basada en la respuesta\n * @param {string} text - Texto de respuesta\n * @param {Array} options - Lista de opciones\n * @returns {Object} - Opción seleccionada y nivel de confianza\n */\nconst findBestMatchingOption = (text, options) => {\n  if (!text || !options || options.length === 0) {\n    return {\n      selected: null,\n      confidence: 0\n    };\n  }\n  const normalizedText = text.toLowerCase();\n\n  // Buscar coincidencias exactas primero (por número o texto completo)\n  const numbers = extractNumbers(normalizedText);\n\n  // Si hay un número que corresponde a un índice válido\n  if (numbers.length > 0) {\n    const index = numbers[0] - 1; // Restar 1 porque los usuarios suelen contar desde 1\n    if (index >= 0 && index < options.length) {\n      return {\n        selected: options[index],\n        confidence: 0.9\n      };\n    }\n  }\n\n  // Buscar por texto\n  let bestMatch = null;\n  let highestConfidence = 0;\n  options.forEach(option => {\n    const optionText = option.toLowerCase();\n\n    // Calcular similitud simple basada en inclusión\n    if (normalizedText.includes(optionText)) {\n      const confidence = optionText.length / normalizedText.length;\n      if (confidence > highestConfidence) {\n        highestConfidence = confidence;\n        bestMatch = option;\n      }\n    } else if (optionText.includes(normalizedText)) {\n      const confidence = normalizedText.length / optionText.length * 0.8; // Penalización\n      if (confidence > highestConfidence) {\n        highestConfidence = confidence;\n        bestMatch = option;\n      }\n    }\n  });\n  return {\n    selected: bestMatch,\n    confidence: highestConfidence\n  };\n};\nexport default {\n  extractName,\n  analyzeIntent,\n  processResponse,\n  analyzeSentiment,\n  generateAdaptiveResponse,\n  analyzeYesNo,\n  extractNumbers,\n  findBestMatchingOption\n};","map":{"version":3,"names":["nlp","nlpEs","plugin","extractName","text","doc","questions","length","console","log","people","out","presentationPhrases","cleanedText","trim","phrase","toLowerCase","includes","parts","split","commonWords","forEach","word","replace","RegExp","words","nameWords","slice","Math","min","map","charAt","toUpperCase","join","analyzeIntent","intent","confidence","affirmations","negations","lowerText","numbers","value","processResponse","questionType","isPositive","sentiment","num","parseInt","max","analyzeSentiment","score","generateAdaptiveResponse","userText","possibleResponses","positiveResponses","filter","r","tone","neutralResponses","negativeResponses","selectedResponses","randomIndex","floor","random","analyzeYesNo","isYes","isNo","yesWords","noWords","yesCount","noCount","extractNumbers","digitMatches","match","allNumbers","uniqueNumbers","Set","parsed","parseFloat","isNaN","findBestMatchingOption","options","selected","normalizedText","index","bestMatch","highestConfidence","option","optionText"],"sources":["C:/Users/josep/Documents/Sistema de Encuestas por Voz/client/src/services/nlpService.js"],"sourcesContent":["import nlp from 'compromise';\nimport nlpEs from 'compromise/plugins/es';\n\n/**\n * Servicio de procesamiento de lenguaje natural para mejorar las interacciones por voz\n * Utiliza compromise.js, una biblioteca ligera de NLP para el navegador\n */\n\n// Registrar el plugin para español\nnlp.plugin(nlpEs);\n\n/**\n * Extraer nombre de una frase con procesamiento avanzado de lenguaje natural\n * @param {string} text - Texto del cual extraer el nombre\n * @returns {string} - Nombre extraído o valor por defecto\n */\nexport const extractName = (text) => {\n  if (!text || typeof text !== 'string') {\n    return 'Estimado participante';\n  }\n\n  // Procesar el texto con NLP\n  const doc = nlp(text);\n  \n  // Verificar si es una pregunta\n  if (doc.questions().length > 0) {\n    console.log('NLP: Se detectó una pregunta en lugar de un nombre');\n    return null;\n  }\n  \n  // Intentar extraer nombre propio (mejor precisión que regex)\n  const people = doc.people().out('array');\n  if (people.length > 0) {\n    console.log('NLP: Nombre extraído usando reconocimiento de entidades:', people[0]);\n    return people[0];\n  }\n  \n  // Extraer frases de presentación\n  const presentationPhrases = ['me llamo', 'mi nombre es', 'soy', 'yo soy', \n    'puedes llamarme', 'puede llamarme', 'llámame', 'llamame'];\n  \n  let cleanedText = text.trim();\n  for (const phrase of presentationPhrases) {\n    if (text.toLowerCase().includes(phrase)) {\n      // Extraer texto después de la frase\n      const parts = text.toLowerCase().split(phrase);\n      if (parts.length > 1 && parts[1].trim()) {\n        cleanedText = parts[1].trim();\n        break;\n      }\n    }\n  }\n  \n  // Eliminar palabras comunes y saludos\n  const commonWords = ['gracias', 'por favor', 'hola', 'buenos días', 'buenas tardes', 'señor', 'señora'];\n  commonWords.forEach(word => {\n    cleanedText = cleanedText.replace(new RegExp(`\\\\b${word}\\\\b`, 'gi'), '');\n  });\n  \n  // Eliminar múltiples espacios y puntuación\n  cleanedText = cleanedText.replace(/\\s+/g, ' ').trim();\n  cleanedText = cleanedText.replace(/[.,;:!?]/g, '').trim();\n  \n  if (!cleanedText) {\n    return 'Estimado participante';\n  }\n  \n  // Tomar las primeras palabras (máximo 3) como nombre\n  const words = cleanedText.split(' ');\n  const nameWords = words.slice(0, Math.min(3, words.length));\n  \n  // Capitalizar cada palabra del nombre\n  return nameWords\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join(' ');\n};\n\n/**\n * Analiza la intención del usuario a partir de su respuesta\n * @param {string} text - Texto de entrada\n * @returns {Object} - Objeto con la intención detectada y confianza\n */\nexport const analyzeIntent = (text) => {\n  if (!text) return { intent: 'unknown', confidence: 0 };\n  \n  const doc = nlp(text);\n  \n  // Detectar si es una pregunta\n  if (doc.questions().length > 0) {\n    return { intent: 'question', confidence: 0.9 };\n  }\n  \n  // Detectar afirmación/negación\n  const affirmations = ['sí', 'si', 'claro', 'por supuesto', 'afirmativo', 'correcto', 'exacto'];\n  const negations = ['no', 'nope', 'negativo', 'para nada', 'en absoluto', 'nunca'];\n  \n  const lowerText = text.toLowerCase();\n  \n  for (const word of affirmations) {\n    if (lowerText.includes(word)) {\n      return { intent: 'affirmation', confidence: 0.85 };\n    }\n  }\n  \n  for (const word of negations) {\n    if (lowerText.includes(word)) {\n      return { intent: 'negation', confidence: 0.85 };\n    }\n  }\n  \n  // Detectar números (para preguntas de calificación)\n  const numbers = doc.numbers().out('array');\n  if (numbers.length > 0) {\n    return { intent: 'number', value: numbers[0], confidence: 0.9 };\n  }\n  \n  return { intent: 'statement', confidence: 0.5 };\n};\n\n/**\n * Procesa la respuesta para una pregunta según su tipo\n * @param {string} text - Respuesta del usuario\n * @param {string} questionType - Tipo de pregunta ('yesno', 'rating', 'text')\n * @returns {*} - Respuesta procesada (boolean, number o string)\n */\nexport const processResponse = (text, questionType) => {\n  if (!text) return null;\n  \n  const intent = analyzeIntent(text);\n  console.log('NLP: Intención detectada:', intent);\n  \n  switch (questionType) {\n    case 'yesno':\n      if (intent.intent === 'affirmation') return true;\n      if (intent.intent === 'negation') return false;\n      // Analizar el texto para encontrar afirmación/negación más compleja\n      const isPositive = nlp(text).sentiment() > 0;\n      return isPositive;\n      \n    case 'rating':\n      if (intent.intent === 'number' && intent.value >= 1 && intent.value <= 5) {\n        return intent.value;\n      }\n      // Extraer número del texto\n      const numbers = nlp(text).numbers().out('array');\n      if (numbers.length > 0) {\n        let num = parseInt(numbers[0]);\n        // Limitar al rango 1-5\n        return Math.max(1, Math.min(5, num));\n      }\n      return null;\n      \n    case 'text':\n    default:\n      // Limpiar el texto para obtener la respuesta más relevante\n      const doc = nlp(text);\n      // Eliminar muletillas comunes\n      return doc.out('text');\n  }\n};\n\n/**\n * Analiza el sentimiento de un texto (positivo, negativo, neutral)\n * @param {string} text - Texto a analizar\n * @returns {Object} - Objeto con el sentimiento y su intensidad\n */\nexport const analyzeSentiment = (text) => {\n  if (!text) return { sentiment: 'neutral', score: 0 };\n  \n  const doc = nlp(text);\n  const score = doc.sentiment();\n  \n  let sentiment = 'neutral';\n  if (score > 0.2) sentiment = 'positive';\n  else if (score < -0.2) sentiment = 'negative';\n  \n  return { sentiment, score };\n};\n\n/**\n * Genera una respuesta personalizada basada en el sentimiento del usuario\n * @param {string} userText - Texto del usuario\n * @param {Array} possibleResponses - Array de posibles respuestas\n * @returns {string} - Respuesta seleccionada\n */\nexport const generateAdaptiveResponse = (userText, possibleResponses) => {\n  const sentiment = analyzeSentiment(userText);\n  \n  // Clasificar respuestas según el sentimiento\n  const positiveResponses = possibleResponses.filter(r => r.tone === 'positive');\n  const neutralResponses = possibleResponses.filter(r => r.tone === 'neutral');\n  const negativeResponses = possibleResponses.filter(r => r.tone === 'supportive');\n  \n  // Seleccionar respuesta apropiada según el sentimiento del usuario\n  let selectedResponses;\n  if (sentiment.sentiment === 'positive') {\n    selectedResponses = positiveResponses.length ? positiveResponses : neutralResponses;\n  } else if (sentiment.sentiment === 'negative') {\n    selectedResponses = negativeResponses.length ? negativeResponses : neutralResponses;\n  } else {\n    selectedResponses = neutralResponses.length ? neutralResponses : positiveResponses;\n  }\n  \n  // Si no hay respuestas del tipo adecuado, usar cualquiera\n  if (!selectedResponses.length) {\n    selectedResponses = possibleResponses;\n  }\n  \n  // Elegir aleatoriamente entre las respuestas apropiadas\n  const randomIndex = Math.floor(Math.random() * selectedResponses.length);\n  return selectedResponses[randomIndex].text;\n};\n\n/**\n * Analiza una respuesta de texto para determinar si es afirmativa o negativa\n * @param {string} text - Texto a analizar\n * @returns {Object} - Resultado del análisis\n */\nconst analyzeYesNo = (text) => {\n  if (!text) return { isYes: false, isNo: false, confidence: 0 };\n  \n  const doc = nlp(text.toLowerCase());\n  \n  // Palabras afirmativas en español\n  const yesWords = ['sí', 'si', 'claro', 'por supuesto', 'afirmativo', 'efectivamente', \n                   'exacto', 'correcto', 'ok', 'vale', 'bueno', 'cierto'];\n  \n  // Palabras negativas en español\n  const noWords = ['no', 'nunca', 'jamás', 'negativo', 'para nada', 'en absoluto', \n                  'de ninguna manera', 'nada', 'tampoco'];\n  \n  // Buscar coincidencias\n  let yesCount = 0;\n  let noCount = 0;\n  \n  yesWords.forEach(word => {\n    if (text.toLowerCase().includes(word)) {\n      yesCount++;\n    }\n  });\n  \n  noWords.forEach(word => {\n    if (text.toLowerCase().includes(word)) {\n      noCount++;\n    }\n  });\n  \n  // Determinar resultado\n  const isYes = yesCount > 0 && yesCount > noCount;\n  const isNo = noCount > 0 && noCount >= yesCount;\n  \n  // Calcular confianza (0-1)\n  let confidence = 0;\n  if (isYes) {\n    confidence = Math.min(yesCount / 3, 1);\n  } else if (isNo) {\n    confidence = Math.min(noCount / 3, 1);\n  }\n  \n  return { isYes, isNo, confidence };\n};\n\n/**\n * Extrae números de un texto\n * @param {string} text - Texto a analizar\n * @returns {Array} - Lista de números encontrados\n */\nconst extractNumbers = (text) => {\n  if (!text) return [];\n  \n  const doc = nlp(text);\n  const numbers = doc.numbers().out('array');\n  \n  // Intentar extraer números como dígitos\n  const digitMatches = text.match(/\\d+/g) || [];\n  \n  // Combinar resultados y eliminar duplicados\n  const allNumbers = [...numbers, ...digitMatches];\n  const uniqueNumbers = [...new Set(allNumbers)];\n  \n  return uniqueNumbers.map(num => {\n    // Intentar convertir a número\n    const parsed = parseFloat(num);\n    return isNaN(parsed) ? num : parsed;\n  });\n};\n\n/**\n * Determina la opción más probable de una lista basada en la respuesta\n * @param {string} text - Texto de respuesta\n * @param {Array} options - Lista de opciones\n * @returns {Object} - Opción seleccionada y nivel de confianza\n */\nconst findBestMatchingOption = (text, options) => {\n  if (!text || !options || options.length === 0) {\n    return { selected: null, confidence: 0 };\n  }\n  \n  const normalizedText = text.toLowerCase();\n  \n  // Buscar coincidencias exactas primero (por número o texto completo)\n  const numbers = extractNumbers(normalizedText);\n  \n  // Si hay un número que corresponde a un índice válido\n  if (numbers.length > 0) {\n    const index = numbers[0] - 1; // Restar 1 porque los usuarios suelen contar desde 1\n    if (index >= 0 && index < options.length) {\n      return { selected: options[index], confidence: 0.9 };\n    }\n  }\n  \n  // Buscar por texto\n  let bestMatch = null;\n  let highestConfidence = 0;\n  \n  options.forEach(option => {\n    const optionText = option.toLowerCase();\n    \n    // Calcular similitud simple basada en inclusión\n    if (normalizedText.includes(optionText)) {\n      const confidence = optionText.length / normalizedText.length;\n      if (confidence > highestConfidence) {\n        highestConfidence = confidence;\n        bestMatch = option;\n      }\n    } else if (optionText.includes(normalizedText)) {\n      const confidence = normalizedText.length / optionText.length * 0.8; // Penalización\n      if (confidence > highestConfidence) {\n        highestConfidence = confidence;\n        bestMatch = option;\n      }\n    }\n  });\n  \n  return { selected: bestMatch, confidence: highestConfidence };\n};\n\nexport default {\n  extractName,\n  analyzeIntent,\n  processResponse,\n  analyzeSentiment,\n  generateAdaptiveResponse,\n  analyzeYesNo,\n  extractNumbers,\n  findBestMatchingOption\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}