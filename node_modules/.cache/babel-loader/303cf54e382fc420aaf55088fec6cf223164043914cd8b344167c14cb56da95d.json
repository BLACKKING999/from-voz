{"ast":null,"code":"/**\n * Servicio de audio mejorado para encuestas por voz\n * Implementa síntesis y reconocimiento de voz con temporizaciones naturales\n * y mejor detección de voz humana\n */\n\nclass AudioService {\n  constructor() {\n    // Variables de estado para síntesis de voz\n    this.cachedVoices = null;\n    this.isSpeaking = false;\n    this.currentUtterance = null;\n    this.resumeInterval = null;\n    this.utteranceTimeoutId = null;\n\n    // Variables para reconocimiento de voz\n    this.recognition = null;\n    this.isListening = false;\n    this.recognitionLang = 'es-ES';\n    this.finalTranscript = '';\n    this.interimTranscript = '';\n    this.microphoneStream = null;\n    this.permissionGranted = false;\n    this.permissionCallback = null;\n\n    // Configuración mejorada para el reconocimiento de voz\n    this.silenceThreshold = 3000; // Tiempo en ms para considerar silencio\n    this.speakingTimeout = 8000; // Tiempo en ms para esperar respuesta\n    this.restartAttempts = 0; // Contador de intentos de reinicio\n    this.maxRestartAttempts = 3; // Máximo número de reintentos\n    this.silenceTimer = null; // Timer para detectar silencio\n    this.audioContext = null; // Contexto de audio para análisis\n    this.analyser = null; // Analizador de audio\n    this.audioData = null; // Buffer para datos de audio\n    this.volumeCheckInterval = null; // Intervalo para comprobar volumen\n\n    // Inicializar sistema al crear instancia\n    this.initSpeechSystem();\n  }\n\n  /**\n   * Inicializa el sistema de síntesis y precarga las voces\n   */\n  initSpeechSystem() {\n    // Verificar si la API está disponible\n    if (typeof window === 'undefined' || !window.speechSynthesis) {\n      console.error('AudioService: Speech Synthesis no está disponible en este navegador');\n      return false;\n    }\n\n    // Obtener y cachear las voces disponibles\n    const loadVoices = () => {\n      const voices = window.speechSynthesis.getVoices();\n      if (voices.length > 0) {\n        this.cachedVoices = voices;\n\n        // Log información sobre las voces disponibles\n        console.log(`AudioService: ${voices.length} voces disponibles`);\n\n        // Buscar voces en español\n        const spanishVoices = voices.filter(v => v.lang.includes('es') || v.name.toLowerCase().includes('spanish'));\n        if (spanishVoices.length > 0) {\n          console.log('AudioService: Voces en español disponibles:', spanishVoices.map(v => `${v.name} (${v.lang})`).join(', '));\n        } else {\n          console.warn('AudioService: No se encontraron voces en español');\n        }\n      }\n    };\n\n    // Chrome requiere este evento\n    if (window.speechSynthesis.onvoiceschanged !== undefined) {\n      window.speechSynthesis.onvoiceschanged = loadVoices;\n    }\n\n    // Intentar cargar las voces inmediatamente también\n    loadVoices();\n    return true;\n  }\n\n  /**\n   * Verifica si el sistema está actualmente hablando\n   */\n  checkIfSpeaking() {\n    return window.speechSynthesis && window.speechSynthesis.speaking;\n  }\n\n  /**\n   * Detiene cualquier síntesis de voz en curso\n   */\n  cancelSpeech() {\n    if (!window.speechSynthesis) return;\n\n    // Cancelar cualquier síntesis en curso\n    window.speechSynthesis.cancel();\n\n    // Limpiar temporizadores\n    if (this.resumeInterval) {\n      clearInterval(this.resumeInterval);\n      this.resumeInterval = null;\n    }\n    if (this.utteranceTimeoutId) {\n      clearTimeout(this.utteranceTimeoutId);\n      this.utteranceTimeoutId = null;\n    }\n    this.isSpeaking = false;\n    this.currentUtterance = null;\n  }\n\n  /**\n   * Habla el texto dado usando técnicas avanzadas para mejorar la confiabilidad\n   * Incluye manejo de tiempos naturales entre frases\n   */\n  speakText(text, onStarted, onEnded, onError) {\n    if (!text || text.trim() === '') {\n      if (onError) onError('Texto vacío');\n      return () => {};\n    }\n    if (typeof window === 'undefined' || !window.speechSynthesis) {\n      if (onError) onError('Speech Synthesis no está disponible en este navegador');\n      return () => {};\n    }\n\n    // Si ya estamos hablando, crear una cola temporal\n    if (this.isSpeaking) {\n      console.log('AudioService: Ya estamos hablando, esperando...');\n      // Cancelamos la síntesis actual y esperamos un momento antes de comenzar la nueva\n      this.cancelSpeech();\n\n      // Esperar 500ms para asegurar que termine la síntesis anterior\n      setTimeout(() => {\n        this.speakText(text, onStarted, onEnded, onError);\n      }, 500);\n      return () => {};\n    }\n    try {\n      // Marcar que estamos hablando ahora\n      this.isSpeaking = true;\n\n      // Crear el objeto de síntesis\n      const utterance = new SpeechSynthesisUtterance(text);\n      this.currentUtterance = utterance;\n\n      // Configurar parámetros básicos\n      utterance.lang = 'es-ES';\n      utterance.rate = 1.0; // Velocidad normal\n      utterance.pitch = 1.0; // Tono normal\n      utterance.volume = 1.0; // Volumen máximo\n\n      // Obtener voces y seleccionar una voz en español si está disponible\n      const voices = this.cachedVoices || window.speechSynthesis.getVoices();\n      const spanishVoice = voices.find(voice => voice.lang.includes('es') || voice.name.toLowerCase().includes('spanish'));\n      if (spanishVoice) {\n        console.log(`AudioService: Usando voz ${spanishVoice.name}`);\n        utterance.voice = spanishVoice;\n      } else if (voices.length > 0) {\n        console.log(`AudioService: No hay voces en español, usando ${voices[0].name}`);\n        utterance.voice = voices[0];\n      }\n\n      // Configurar eventos\n      utterance.onstart = () => {\n        console.log('AudioService: Síntesis iniciada');\n        if (onStarted) onStarted();\n      };\n      utterance.onend = () => {\n        console.log('AudioService: Síntesis completada');\n        this.isSpeaking = false;\n\n        // Limpiar temporizadores\n        if (this.resumeInterval) {\n          clearInterval(this.resumeInterval);\n          this.resumeInterval = null;\n        }\n        if (this.utteranceTimeoutId) {\n          clearTimeout(this.utteranceTimeoutId);\n          this.utteranceTimeoutId = null;\n        }\n\n        // Esperar un momento antes de llamar al callback para simular una pausa natural\n        setTimeout(() => {\n          if (onEnded) onEnded();\n        }, 500); // Aumentado de 300ms a 500ms para una pausa más natural\n      };\n      utterance.onerror = event => {\n        console.error('AudioService: Error en síntesis:', event);\n        this.isSpeaking = false;\n\n        // Limpiar temporizadores\n        if (this.resumeInterval) {\n          clearInterval(this.resumeInterval);\n          this.resumeInterval = null;\n        }\n        if (this.utteranceTimeoutId) {\n          clearTimeout(this.utteranceTimeoutId);\n          this.utteranceTimeoutId = null;\n        }\n        if (onError) onError(event.error || 'Error desconocido');\n      };\n\n      // Cancelar cualquier síntesis previa\n      window.speechSynthesis.cancel();\n\n      // Iniciar síntesis después de una breve pausa para evitar conflictos\n      setTimeout(() => {\n        // Iniciar la síntesis\n        window.speechSynthesis.speak(utterance);\n\n        // *** WORKAROUNDS CRÍTICOS ***\n\n        // 1. Workaround para el problema de Chrome donde la síntesis se detiene después de ~15s\n        this.resumeInterval = setInterval(() => {\n          if (window.speechSynthesis.speaking) {\n            console.log('AudioService: Aplicando workaround de pausa/resume');\n            window.speechSynthesis.pause();\n            window.speechSynthesis.resume();\n          } else {\n            clearInterval(this.resumeInterval);\n            this.resumeInterval = null;\n          }\n        }, 10000);\n\n        // 2. Workaround para el caso donde onend no se dispara\n        // Tiempo basado en la longitud del texto (125ms por caracter) con un mínimo de 8 segundos\n        // Aumentado para dar más tiempo a la síntesis\n        const maxSpeakingTime = Math.max(8000, text.length * 125);\n        this.utteranceTimeoutId = setTimeout(() => {\n          if (window.speechSynthesis.speaking) {\n            console.log(`AudioService: Detectado posible bloqueo después de ${maxSpeakingTime}ms, forzando finalización`);\n            window.speechSynthesis.cancel();\n            this.isSpeaking = false;\n            if (onEnded) onEnded();\n          }\n          if (this.resumeInterval) {\n            clearInterval(this.resumeInterval);\n            this.resumeInterval = null;\n          }\n        }, maxSpeakingTime);\n      }, 150); // Aumentado de 100ms a 150ms para mayor estabilidad\n\n      return () => {\n        this.cancelSpeech();\n      };\n    } catch (error) {\n      console.error('AudioService: Error general:', error);\n      this.isSpeaking = false;\n      if (onError) onError(error.message || 'Error desconocido');\n      return () => {};\n    }\n  }\n\n  /**\n   * Inicializa el reconocimiento de voz con configuración mejorada\n   * @param {string} language - Idioma para el reconocimiento (por defecto es español)\n   */\n  init(language = 'es-ES') {\n    if (!this.isSupportedByBrowser()) {\n      console.error('El reconocimiento de voz no está soportado en este navegador');\n      return false;\n    }\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    this.recognition = new SpeechRecognition();\n\n    // Configurar opciones con valores mejorados\n    this.recognition.lang = language;\n    this.recognition.continuous = true; // Cambiado a true para mantener escuchando\n    this.recognition.interimResults = true;\n    this.recognition.maxAlternatives = 3; // Obtener múltiples alternativas para mejor precisión\n\n    // Configurar eventos\n    this.recognition.onresult = event => {\n      // Resetear el temporizador de silencio cuando hay actividad\n      this.resetSilenceTimer();\n\n      // Procesar resultados de reconocimiento\n      let interimTranscript = '';\n      let finalTranscript = '';\n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const transcript = event.results[i][0].transcript;\n        if (event.results[i].isFinal) {\n          finalTranscript += transcript;\n        } else {\n          interimTranscript += transcript;\n        }\n      }\n\n      // Actualizar variables de estado\n      this.interimTranscript = interimTranscript;\n      if (finalTranscript) {\n        this.finalTranscript += ' ' + finalTranscript;\n        this.finalTranscript = this.finalTranscript.trim();\n      }\n\n      // Notificar resultados\n      if (this.onResultCallback) {\n        this.onResultCallback(this.finalTranscript, event.results[event.resultIndex].isFinal, this.interimTranscript);\n      }\n    };\n    this.recognition.onend = () => {\n      console.log('AudioService: Reconocimiento finalizado');\n\n      // Detener análisis de audio si está activo\n      this.stopAudioAnalysis();\n\n      // Si estábamos escuchando activamente y hay un temporizador de silencio,\n      // esperamos un poco más antes de considerar que realmente terminó\n      if (this.isListening && this.silenceTimer) {\n        console.log('AudioService: Esperando un poco más antes de finalizar...');\n\n        // Esperar un poco más antes de considerar realmente finalizado\n        setTimeout(() => {\n          this.isListening = false;\n\n          // Notificar finalización\n          if (this.onEndCallback) {\n            this.onEndCallback(this.finalTranscript);\n          }\n\n          // Resetear intentos de reinicio\n          this.restartAttempts = 0;\n        }, 1000);\n      } else {\n        this.isListening = false;\n\n        // Notificar finalización\n        if (this.onEndCallback) {\n          this.onEndCallback(this.finalTranscript);\n        }\n\n        // Resetear intentos de reinicio\n        this.restartAttempts = 0;\n      }\n    };\n    this.recognition.onerror = event => {\n      console.log('AudioService: Error de reconocimiento:', event.error);\n\n      // No marcar como no escuchando inmediatamente para ciertos errores\n      if (event.error !== 'no-speech' && event.error !== 'audio-capture') {\n        this.isListening = false;\n      }\n\n      // Manejo de errores mejorado\n      if (event.error === 'no-speech') {\n        // Para errores de no-speech, intentamos reiniciar si estamos dentro del límite de intentos\n        if (this.restartAttempts < this.maxRestartAttempts) {\n          this.restartAttempts++;\n          console.log(`AudioService: Reintentando reconocimiento (intento ${this.restartAttempts}/${this.maxRestartAttempts})`);\n          if (this.onErrorCallback) {\n            this.onErrorCallback('waiting');\n          }\n\n          // Intentar reiniciar tras un breve retraso\n          setTimeout(() => {\n            if (!this.isListening) {\n              // Solo si no estamos escuchando activamente\n              try {\n                this.startRecognition();\n              } catch (e) {\n                console.error('Error al reiniciar reconocimiento:', e);\n                if (this.onErrorCallback) {\n                  this.onErrorCallback('error_restart');\n                }\n              }\n            }\n          }, 1500); // Incrementado a 1.5s para dar más tiempo\n        } else {\n          console.log('AudioService: Máximo de reintentos alcanzado');\n          if (this.onErrorCallback) {\n            this.onErrorCallback('max_restarts');\n          }\n        }\n      } else if (this.onErrorCallback) {\n        // Para otros errores, enviamos el mensaje original\n        this.onErrorCallback(event.error);\n      }\n    };\n    this.recognition.onnomatch = () => {\n      console.log('AudioService: No se pudo encontrar una coincidencia');\n\n      // Considerar reiniciar el reconocimiento\n      if (this.restartAttempts < this.maxRestartAttempts) {\n        this.restartAttempts++;\n        setTimeout(() => {\n          try {\n            this.startRecognition();\n          } catch (e) {\n            console.error('Error al reiniciar tras no coincidencia:', e);\n          }\n        }, 1000);\n      }\n    };\n    this.recognition.onaudiostart = () => {\n      console.log('AudioService: Audio detectado, reconocimiento activo');\n      // Iniciar análisis de audio si es posible\n      this.setupAudioAnalysis();\n    };\n    return true;\n  }\n\n  /**\n   * Configura el análisis de audio para mejor detección de voz\n   */\n  setupAudioAnalysis() {\n    // Solo configurar si tenemos acceso al stream\n    if (!this.microphoneStream) return;\n    try {\n      // Crear contexto de audio si no existe\n      if (!this.audioContext) {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        this.audioContext = new AudioContext();\n      }\n\n      // Crear analizador de audio\n      this.analyser = this.audioContext.createAnalyser();\n      this.analyser.fftSize = 256;\n\n      // Conectar el stream de micrófono al analizador\n      const source = this.audioContext.createMediaStreamSource(this.microphoneStream);\n      source.connect(this.analyser);\n\n      // Preparar buffer para datos\n      this.audioData = new Uint8Array(this.analyser.frequencyBinCount);\n\n      // Iniciar monitoreo de volumen\n      this.startVolumeMonitoring();\n    } catch (error) {\n      console.error('Error al configurar análisis de audio:', error);\n    }\n  }\n\n  /**\n   * Inicia el monitoreo de volumen para mejor detección de voz\n   */\n  startVolumeMonitoring() {\n    // Detener monitoreo previo si existe\n    this.stopVolumeMonitoring();\n\n    // Iniciar nuevo intervalo de monitoreo\n    this.volumeCheckInterval = setInterval(() => {\n      if (!this.analyser || !this.audioData) return;\n\n      // Obtener datos de frecuencia actual\n      this.analyser.getByteFrequencyData(this.audioData);\n\n      // Calcular volumen promedio\n      let sum = 0;\n      for (let i = 0; i < this.audioData.length; i++) {\n        sum += this.audioData[i];\n      }\n      const averageVolume = sum / this.audioData.length;\n\n      // Umbral de detección de voz (ajustable)\n      const voiceThreshold = 15;\n      if (averageVolume > voiceThreshold) {\n        // Se detectó voz, resetear temporizador de silencio\n        this.resetSilenceTimer();\n      }\n\n      // Log de debug cada cierto tiempo\n      if (Math.random() < 0.05) {\n        // Solo loggear aproximadamente 5% del tiempo\n        console.log(`AudioService: Volumen promedio: ${averageVolume.toFixed(2)}`);\n      }\n    }, 200); // Comprobar cada 200ms\n  }\n\n  /**\n   * Detiene el monitoreo de volumen\n   */\n  stopVolumeMonitoring() {\n    if (this.volumeCheckInterval) {\n      clearInterval(this.volumeCheckInterval);\n      this.volumeCheckInterval = null;\n    }\n  }\n\n  /**\n   * Detiene el análisis de audio\n   */\n  stopAudioAnalysis() {\n    this.stopVolumeMonitoring();\n\n    // Liberar recursos de audio\n    if (this.audioContext && this.audioContext.state !== 'closed') {\n      // No cerramos el contexto para poder reutilizarlo, solo desconectamos\n      if (this.analyser) {\n        this.analyser.disconnect();\n        this.analyser = null;\n      }\n    }\n    this.audioData = null;\n  }\n\n  /**\n   * Reinicia el temporizador de silencio\n   */\n  resetSilenceTimer() {\n    // Limpiar temporizador existente\n    if (this.silenceTimer) {\n      clearTimeout(this.silenceTimer);\n      this.silenceTimer = null;\n    }\n\n    // Configurar nuevo temporizador\n    this.silenceTimer = setTimeout(() => {\n      console.log(`AudioService: Silencio detectado después de ${this.silenceThreshold}ms`);\n\n      // Si seguimos escuchando, es tiempo de considerar que el usuario ha terminado\n      if (this.isListening) {\n        console.log('AudioService: Deteniendo reconocimiento por silencio prolongado');\n        this.stop();\n      }\n    }, this.silenceThreshold);\n  }\n\n  /**\n   * Método interno para iniciar el reconocimiento (usado para reintentos)\n   */\n  startRecognition() {\n    if (this.recognition) {\n      try {\n        this.recognition.start();\n        this.isListening = true;\n\n        // Iniciar temporizador de silencio\n        this.resetSilenceTimer();\n\n        // Configurar temporizador de tiempo máximo de espera\n        setTimeout(() => {\n          if (this.isListening) {\n            console.log(`AudioService: Tiempo máximo de espera (${this.speakingTimeout}ms) alcanzado`);\n            // No detener directamente, sino revisar si hay actividad\n            if (!this.finalTranscript && !this.interimTranscript) {\n              console.log('AudioService: No se detectó voz, deteniendo');\n              this.stop();\n            }\n          }\n        }, this.speakingTimeout);\n        return true;\n      } catch (error) {\n        console.error('Error al iniciar reconocimiento:', error);\n        this.isListening = false;\n        return false;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Solicita permiso para usar el micrófono con opciones mejoradas\n   * @returns {Promise<boolean>} - Promise que resuelve a true si se otorgó permiso, false en caso contrario\n   */\n  async requestMicrophonePermission() {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      try {\n        // Solicitar acceso al micrófono con configuración óptima\n        const constraints = {\n          audio: {\n            echoCancellation: true,\n            noiseSuppression: true,\n            autoGainControl: true,\n            channelCount: 1 // Mono para mejor reconocimiento de voz\n          }\n        };\n        const stream = await navigator.mediaDevices.getUserMedia(constraints);\n\n        // Almacenar la referencia al stream para poder detenerlo después\n        this.microphoneStream = stream;\n        this.permissionGranted = true;\n\n        // Notificar que el permiso fue concedido si hay un callback\n        if (this.permissionCallback) {\n          this.permissionCallback(true);\n        }\n        return true;\n      } catch (error) {\n        console.error('Error al solicitar permiso para el micrófono:', error);\n        this.permissionGranted = false;\n        // Notificar que el permiso fue denegado si hay un callback\n        if (this.permissionCallback) {\n          this.permissionCallback(false, error.message);\n        }\n        return false;\n      }\n    } else {\n      console.error('getUserMedia no está soportado en este navegador');\n      return false;\n    }\n  }\n\n  /**\n   * Establece el callback para cuando cambia el estado del permiso del micrófono\n   * @param {Function} callback - Función a llamar cuando cambia el estado del permiso\n   */\n  onPermissionChange(callback) {\n    this.permissionCallback = callback;\n  }\n\n  /**\n   * Configura los tiempos de espera para el reconocimiento de voz\n   * @param {Object} options - Opciones de configuración\n   * @param {number} options.silenceThreshold - Tiempo en ms para considerar silencio (por defecto 3000ms)\n   * @param {number} options.speakingTimeout - Tiempo máximo de espera para una respuesta (por defecto 8000ms)\n   */\n  configureTimings(options = {}) {\n    if (options.silenceThreshold && typeof options.silenceThreshold === 'number') {\n      this.silenceThreshold = options.silenceThreshold;\n    }\n    if (options.speakingTimeout && typeof options.speakingTimeout === 'number') {\n      this.speakingTimeout = options.speakingTimeout;\n    }\n    console.log(`AudioService: Tiempos configurados - Silencio: ${this.silenceThreshold}ms, Espera máxima: ${this.speakingTimeout}ms`);\n  }\n\n  /**\n   * Inicia el reconocimiento de voz, solicitando permisos si es necesario\n   * @param {Object} options - Opciones opcionales para la configuración\n   * @returns {Promise<boolean>} - Promise que resuelve a true si se inició correctamente\n   */\n  async start(options = {}) {\n    // Actualizar configuración si se proporcionan opciones\n    if (options.silenceThreshold || options.speakingTimeout) {\n      this.configureTimings(options);\n    }\n\n    // Detener cualquier reconocimiento previo primero\n    this.stop();\n\n    // Pequeña pausa para asegurar que el reconocimiento anterior se detuvo correctamente\n    await new Promise(resolve => setTimeout(resolve, 400));\n\n    // Verificar y solicitar permiso si no ha sido otorgado\n    if (!this.permissionGranted) {\n      const permissionGranted = await this.requestMicrophonePermission();\n      if (!permissionGranted) {\n        if (this.onErrorCallback) {\n          this.onErrorCallback('No se otorgó permiso para usar el micrófono');\n        }\n        return false;\n      }\n    }\n    if (!this.recognition) {\n      const initialized = this.init(options.language || this.recognitionLang);\n      if (!initialized) return false;\n    }\n\n    // Reiniciar transcripciones\n    this.finalTranscript = '';\n    this.interimTranscript = '';\n\n    // Resetear contador de intentos\n    this.restartAttempts = 0;\n    console.log('AudioService: Iniciando reconocimiento de voz');\n    return this.startRecognition();\n  }\n\n  /**\n   * Detiene el reconocimiento de voz\n   */\n  stop() {\n    // Limpiar temporizador de silencio\n    if (this.silenceTimer) {\n      clearTimeout(this.silenceTimer);\n      this.silenceTimer = null;\n    }\n\n    // Detener análisis de audio\n    this.stopAudioAnalysis();\n    if (this.recognition && this.isListening) {\n      try {\n        this.recognition.stop();\n        this.isListening = false;\n\n        // También detener el stream del micrófono si existe\n        if (this.microphoneStream) {\n          this.microphoneStream.getTracks().forEach(track => track.stop());\n        }\n        return true;\n      } catch (error) {\n        console.error('Error al detener el reconocimiento de voz:', error);\n        this.isListening = false;\n        return false;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Establece el callback para cuando se recibe un resultado\n   * @param {Function} callback - Función a llamar con el resultado\n   */\n  onResult(callback) {\n    this.onResultCallback = callback;\n  }\n\n  /**\n   * Establece el callback para cuando termina el reconocimiento\n   * @param {Function} callback - Función a llamar al terminar\n   */\n  onEnd(callback) {\n    this.onEndCallback = callback;\n  }\n\n  /**\n   * Establece el callback para cuando ocurre un error\n   * @param {Function} callback - Función a llamar en caso de error\n   */\n  onError(callback) {\n    this.onErrorCallback = callback;\n  }\n\n  /**\n   * Verifica si el navegador soporta reconocimiento de voz\n   * @returns {boolean} - true si es soportado, false si no\n   */\n  isSupportedByBrowser() {\n    return typeof window !== 'undefined' && ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window);\n  }\n\n  /**\n   * Ajusta la sensibilidad del reconocimiento de voz\n   * @param {Object} options - Opciones de sensibilidad\n   * @param {number} options.silenceThreshold - Tiempo en ms para considerar silencio (3000-10000)\n   * @param {number} options.speakingTimeout - Tiempo máximo de espera para una respuesta (5000-30000)\n   */\n  setSensitivity(options = {}) {\n    // Valores predefinidos para diferentes sensibilidades\n    const sensitivities = {\n      high: {\n        silenceThreshold: 2000,\n        speakingTimeout: 5000\n      },\n      medium: {\n        silenceThreshold: 3000,\n        speakingTimeout: 8000\n      },\n      low: {\n        silenceThreshold: 5000,\n        speakingTimeout: 15000\n      },\n      veryLow: {\n        silenceThreshold: 8000,\n        speakingTimeout: 30000\n      }\n    };\n    let config = {\n      ...sensitivities.medium\n    }; // Valor por defecto\n\n    // Si se proporciona un preset de sensibilidad\n    if (options.preset && sensitivities[options.preset]) {\n      config = {\n        ...sensitivities[options.preset]\n      };\n    }\n\n    // Sobrescribir con valores específicos si se proporcionan\n    if (options.silenceThreshold) config.silenceThreshold = options.silenceThreshold;\n    if (options.speakingTimeout) config.speakingTimeout = options.speakingTimeout;\n\n    // Aplicar configuración\n    this.configureTimings(config);\n    return config;\n  }\n}\n\n// Exportar una instancia única del servicio\nconst audioService = new AudioService();\nexport default audioService;","map":{"version":3,"names":["AudioService","constructor","cachedVoices","isSpeaking","currentUtterance","resumeInterval","utteranceTimeoutId","recognition","isListening","recognitionLang","finalTranscript","interimTranscript","microphoneStream","permissionGranted","permissionCallback","silenceThreshold","speakingTimeout","restartAttempts","maxRestartAttempts","silenceTimer","audioContext","analyser","audioData","volumeCheckInterval","initSpeechSystem","window","speechSynthesis","console","error","loadVoices","voices","getVoices","length","log","spanishVoices","filter","v","lang","includes","name","toLowerCase","map","join","warn","onvoiceschanged","undefined","checkIfSpeaking","speaking","cancelSpeech","cancel","clearInterval","clearTimeout","speakText","text","onStarted","onEnded","onError","trim","setTimeout","utterance","SpeechSynthesisUtterance","rate","pitch","volume","spanishVoice","find","voice","onstart","onend","onerror","event","speak","setInterval","pause","resume","maxSpeakingTime","Math","max","message","init","language","isSupportedByBrowser","SpeechRecognition","webkitSpeechRecognition","continuous","interimResults","maxAlternatives","onresult","resetSilenceTimer","i","resultIndex","results","transcript","isFinal","onResultCallback","stopAudioAnalysis","onEndCallback","onErrorCallback","startRecognition","e","onnomatch","onaudiostart","setupAudioAnalysis","AudioContext","webkitAudioContext","createAnalyser","fftSize","source","createMediaStreamSource","connect","Uint8Array","frequencyBinCount","startVolumeMonitoring","stopVolumeMonitoring","getByteFrequencyData","sum","averageVolume","voiceThreshold","random","toFixed","state","disconnect","stop","start","requestMicrophonePermission","navigator","mediaDevices","getUserMedia","constraints","audio","echoCancellation","noiseSuppression","autoGainControl","channelCount","stream","onPermissionChange","callback","configureTimings","options","Promise","resolve","initialized","getTracks","forEach","track","onResult","onEnd","setSensitivity","sensitivities","high","medium","low","veryLow","config","preset","audioService"],"sources":["C:/Users/josep/Documents/Sistema de Encuestas por Voz/client/src/services/audioService.js"],"sourcesContent":["/**\n * Servicio de audio mejorado para encuestas por voz\n * Implementa síntesis y reconocimiento de voz con temporizaciones naturales\n * y mejor detección de voz humana\n */\n\nclass AudioService {\n  constructor() {\n    // Variables de estado para síntesis de voz\n    this.cachedVoices = null;\n    this.isSpeaking = false;\n    this.currentUtterance = null;\n    this.resumeInterval = null;\n    this.utteranceTimeoutId = null;\n    \n    // Variables para reconocimiento de voz\n    this.recognition = null;\n    this.isListening = false;\n    this.recognitionLang = 'es-ES';\n    this.finalTranscript = '';\n    this.interimTranscript = '';\n    this.microphoneStream = null;\n    this.permissionGranted = false;\n    this.permissionCallback = null;\n    \n    // Configuración mejorada para el reconocimiento de voz\n    this.silenceThreshold = 3000; // Tiempo en ms para considerar silencio\n    this.speakingTimeout = 8000;  // Tiempo en ms para esperar respuesta\n    this.restartAttempts = 0;     // Contador de intentos de reinicio\n    this.maxRestartAttempts = 3;  // Máximo número de reintentos\n    this.silenceTimer = null;     // Timer para detectar silencio\n    this.audioContext = null;     // Contexto de audio para análisis\n    this.analyser = null;         // Analizador de audio\n    this.audioData = null;        // Buffer para datos de audio\n    this.volumeCheckInterval = null; // Intervalo para comprobar volumen\n    \n    // Inicializar sistema al crear instancia\n    this.initSpeechSystem();\n  }\n  \n  /**\n   * Inicializa el sistema de síntesis y precarga las voces\n   */\n  initSpeechSystem() {\n    // Verificar si la API está disponible\n    if (typeof window === 'undefined' || !window.speechSynthesis) {\n      console.error('AudioService: Speech Synthesis no está disponible en este navegador');\n      return false;\n    }\n  \n    // Obtener y cachear las voces disponibles\n    const loadVoices = () => {\n      const voices = window.speechSynthesis.getVoices();\n      if (voices.length > 0) {\n        this.cachedVoices = voices;\n        \n        // Log información sobre las voces disponibles\n        console.log(`AudioService: ${voices.length} voces disponibles`);\n        \n        // Buscar voces en español\n        const spanishVoices = voices.filter(v => \n          v.lang.includes('es') || \n          v.name.toLowerCase().includes('spanish')\n        );\n        \n        if (spanishVoices.length > 0) {\n          console.log('AudioService: Voces en español disponibles:', \n            spanishVoices.map(v => `${v.name} (${v.lang})`).join(', ')\n          );\n        } else {\n          console.warn('AudioService: No se encontraron voces en español');\n        }\n      }\n    };\n  \n    // Chrome requiere este evento\n    if (window.speechSynthesis.onvoiceschanged !== undefined) {\n      window.speechSynthesis.onvoiceschanged = loadVoices;\n    }\n  \n    // Intentar cargar las voces inmediatamente también\n    loadVoices();\n  \n    return true;\n  }\n\n  /**\n   * Verifica si el sistema está actualmente hablando\n   */\n  checkIfSpeaking() {\n    return window.speechSynthesis && window.speechSynthesis.speaking;\n  }\n\n  /**\n   * Detiene cualquier síntesis de voz en curso\n   */\n  cancelSpeech() {\n    if (!window.speechSynthesis) return;\n    \n    // Cancelar cualquier síntesis en curso\n    window.speechSynthesis.cancel();\n    \n    // Limpiar temporizadores\n    if (this.resumeInterval) {\n      clearInterval(this.resumeInterval);\n      this.resumeInterval = null;\n    }\n    \n    if (this.utteranceTimeoutId) {\n      clearTimeout(this.utteranceTimeoutId);\n      this.utteranceTimeoutId = null;\n    }\n    \n    this.isSpeaking = false;\n    this.currentUtterance = null;\n  }\n\n  /**\n   * Habla el texto dado usando técnicas avanzadas para mejorar la confiabilidad\n   * Incluye manejo de tiempos naturales entre frases\n   */\n  speakText(text, onStarted, onEnded, onError) {\n    if (!text || text.trim() === '') {\n      if (onError) onError('Texto vacío');\n      return () => {};\n    }\n    \n    if (typeof window === 'undefined' || !window.speechSynthesis) {\n      if (onError) onError('Speech Synthesis no está disponible en este navegador');\n      return () => {};\n    }\n    \n    // Si ya estamos hablando, crear una cola temporal\n    if (this.isSpeaking) {\n      console.log('AudioService: Ya estamos hablando, esperando...');\n      // Cancelamos la síntesis actual y esperamos un momento antes de comenzar la nueva\n      this.cancelSpeech();\n      \n      // Esperar 500ms para asegurar que termine la síntesis anterior\n      setTimeout(() => {\n        this.speakText(text, onStarted, onEnded, onError);\n      }, 500);\n      \n      return () => {};\n    }\n    \n    try {\n      // Marcar que estamos hablando ahora\n      this.isSpeaking = true;\n      \n      // Crear el objeto de síntesis\n      const utterance = new SpeechSynthesisUtterance(text);\n      this.currentUtterance = utterance;\n      \n      // Configurar parámetros básicos\n      utterance.lang = 'es-ES';\n      utterance.rate = 1.0;     // Velocidad normal\n      utterance.pitch = 1.0;    // Tono normal\n      utterance.volume = 1.0;   // Volumen máximo\n      \n      // Obtener voces y seleccionar una voz en español si está disponible\n      const voices = this.cachedVoices || window.speechSynthesis.getVoices();\n      const spanishVoice = voices.find(voice => \n        voice.lang.includes('es') || \n        voice.name.toLowerCase().includes('spanish')\n      );\n      \n      if (spanishVoice) {\n        console.log(`AudioService: Usando voz ${spanishVoice.name}`);\n        utterance.voice = spanishVoice;\n      } else if (voices.length > 0) {\n        console.log(`AudioService: No hay voces en español, usando ${voices[0].name}`);\n        utterance.voice = voices[0];\n      }\n      \n      // Configurar eventos\n      utterance.onstart = () => {\n        console.log('AudioService: Síntesis iniciada');\n        if (onStarted) onStarted();\n      };\n      \n      utterance.onend = () => {\n        console.log('AudioService: Síntesis completada');\n        this.isSpeaking = false;\n        \n        // Limpiar temporizadores\n        if (this.resumeInterval) {\n          clearInterval(this.resumeInterval);\n          this.resumeInterval = null;\n        }\n        \n        if (this.utteranceTimeoutId) {\n          clearTimeout(this.utteranceTimeoutId);\n          this.utteranceTimeoutId = null;\n        }\n        \n        // Esperar un momento antes de llamar al callback para simular una pausa natural\n        setTimeout(() => {\n          if (onEnded) onEnded();\n        }, 500); // Aumentado de 300ms a 500ms para una pausa más natural\n      };\n      \n      utterance.onerror = (event) => {\n        console.error('AudioService: Error en síntesis:', event);\n        this.isSpeaking = false;\n        \n        // Limpiar temporizadores\n        if (this.resumeInterval) {\n          clearInterval(this.resumeInterval);\n          this.resumeInterval = null;\n        }\n        \n        if (this.utteranceTimeoutId) {\n          clearTimeout(this.utteranceTimeoutId);\n          this.utteranceTimeoutId = null;\n        }\n        \n        if (onError) onError(event.error || 'Error desconocido');\n      };\n      \n      // Cancelar cualquier síntesis previa\n      window.speechSynthesis.cancel();\n      \n      // Iniciar síntesis después de una breve pausa para evitar conflictos\n      setTimeout(() => {\n        // Iniciar la síntesis\n        window.speechSynthesis.speak(utterance);\n        \n        // *** WORKAROUNDS CRÍTICOS ***\n        \n        // 1. Workaround para el problema de Chrome donde la síntesis se detiene después de ~15s\n        this.resumeInterval = setInterval(() => {\n          if (window.speechSynthesis.speaking) {\n            console.log('AudioService: Aplicando workaround de pausa/resume');\n            window.speechSynthesis.pause();\n            window.speechSynthesis.resume();\n          } else {\n            clearInterval(this.resumeInterval);\n            this.resumeInterval = null;\n          }\n        }, 10000);\n        \n        // 2. Workaround para el caso donde onend no se dispara\n        // Tiempo basado en la longitud del texto (125ms por caracter) con un mínimo de 8 segundos\n        // Aumentado para dar más tiempo a la síntesis\n        const maxSpeakingTime = Math.max(8000, text.length * 125);\n        this.utteranceTimeoutId = setTimeout(() => {\n          if (window.speechSynthesis.speaking) {\n            console.log(`AudioService: Detectado posible bloqueo después de ${maxSpeakingTime}ms, forzando finalización`);\n            window.speechSynthesis.cancel();\n            this.isSpeaking = false;\n            \n            if (onEnded) onEnded();\n          }\n          \n          if (this.resumeInterval) {\n            clearInterval(this.resumeInterval);\n            this.resumeInterval = null;\n          }\n        }, maxSpeakingTime);\n      }, 150); // Aumentado de 100ms a 150ms para mayor estabilidad\n      \n      return () => {\n        this.cancelSpeech();\n      };\n    } catch (error) {\n      console.error('AudioService: Error general:', error);\n      this.isSpeaking = false;\n      if (onError) onError(error.message || 'Error desconocido');\n      return () => {};\n    }\n  }\n\n  /**\n   * Inicializa el reconocimiento de voz con configuración mejorada\n   * @param {string} language - Idioma para el reconocimiento (por defecto es español)\n   */\n  init(language = 'es-ES') {\n    if (!this.isSupportedByBrowser()) {\n      console.error('El reconocimiento de voz no está soportado en este navegador');\n      return false;\n    }\n    \n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    this.recognition = new SpeechRecognition();\n    \n    // Configurar opciones con valores mejorados\n    this.recognition.lang = language;\n    this.recognition.continuous = true;  // Cambiado a true para mantener escuchando\n    this.recognition.interimResults = true;\n    this.recognition.maxAlternatives = 3; // Obtener múltiples alternativas para mejor precisión\n    \n    // Configurar eventos\n    this.recognition.onresult = (event) => {\n      // Resetear el temporizador de silencio cuando hay actividad\n      this.resetSilenceTimer();\n      \n      // Procesar resultados de reconocimiento\n      let interimTranscript = '';\n      let finalTranscript = '';\n      \n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const transcript = event.results[i][0].transcript;\n        if (event.results[i].isFinal) {\n          finalTranscript += transcript;\n        } else {\n          interimTranscript += transcript;\n        }\n      }\n      \n      // Actualizar variables de estado\n      this.interimTranscript = interimTranscript;\n      \n      if (finalTranscript) {\n        this.finalTranscript += ' ' + finalTranscript;\n        this.finalTranscript = this.finalTranscript.trim();\n      }\n      \n      // Notificar resultados\n      if (this.onResultCallback) {\n        this.onResultCallback(\n          this.finalTranscript,\n          event.results[event.resultIndex].isFinal,\n          this.interimTranscript\n        );\n      }\n    };\n    \n    this.recognition.onend = () => {\n      console.log('AudioService: Reconocimiento finalizado');\n      \n      // Detener análisis de audio si está activo\n      this.stopAudioAnalysis();\n      \n      // Si estábamos escuchando activamente y hay un temporizador de silencio,\n      // esperamos un poco más antes de considerar que realmente terminó\n      if (this.isListening && this.silenceTimer) {\n        console.log('AudioService: Esperando un poco más antes de finalizar...');\n        \n        // Esperar un poco más antes de considerar realmente finalizado\n        setTimeout(() => {\n          this.isListening = false;\n          \n          // Notificar finalización\n          if (this.onEndCallback) {\n            this.onEndCallback(this.finalTranscript);\n          }\n          \n          // Resetear intentos de reinicio\n          this.restartAttempts = 0;\n        }, 1000);\n      } else {\n        this.isListening = false;\n        \n        // Notificar finalización\n        if (this.onEndCallback) {\n          this.onEndCallback(this.finalTranscript);\n        }\n        \n        // Resetear intentos de reinicio\n        this.restartAttempts = 0;\n      }\n    };\n    \n    this.recognition.onerror = (event) => {\n      console.log('AudioService: Error de reconocimiento:', event.error);\n      \n      // No marcar como no escuchando inmediatamente para ciertos errores\n      if (event.error !== 'no-speech' && event.error !== 'audio-capture') {\n        this.isListening = false;\n      }\n      \n      // Manejo de errores mejorado\n      if (event.error === 'no-speech') {\n        // Para errores de no-speech, intentamos reiniciar si estamos dentro del límite de intentos\n        if (this.restartAttempts < this.maxRestartAttempts) {\n          this.restartAttempts++;\n          \n          console.log(`AudioService: Reintentando reconocimiento (intento ${this.restartAttempts}/${this.maxRestartAttempts})`);\n          \n          if (this.onErrorCallback) {\n            this.onErrorCallback('waiting');\n          }\n          \n          // Intentar reiniciar tras un breve retraso\n          setTimeout(() => {\n            if (!this.isListening) { // Solo si no estamos escuchando activamente\n              try {\n                this.startRecognition();\n              } catch (e) {\n                console.error('Error al reiniciar reconocimiento:', e);\n                \n                if (this.onErrorCallback) {\n                  this.onErrorCallback('error_restart');\n                }\n              }\n            }\n          }, 1500);  // Incrementado a 1.5s para dar más tiempo\n        } else {\n          console.log('AudioService: Máximo de reintentos alcanzado');\n          \n          if (this.onErrorCallback) {\n            this.onErrorCallback('max_restarts');\n          }\n        }\n      } else if (this.onErrorCallback) {\n        // Para otros errores, enviamos el mensaje original\n        this.onErrorCallback(event.error);\n      }\n    };\n    \n    this.recognition.onnomatch = () => {\n      console.log('AudioService: No se pudo encontrar una coincidencia');\n      \n      // Considerar reiniciar el reconocimiento\n      if (this.restartAttempts < this.maxRestartAttempts) {\n        this.restartAttempts++;\n        \n        setTimeout(() => {\n          try {\n            this.startRecognition();\n          } catch (e) {\n            console.error('Error al reiniciar tras no coincidencia:', e);\n          }\n        }, 1000);\n      }\n    };\n    \n    this.recognition.onaudiostart = () => {\n      console.log('AudioService: Audio detectado, reconocimiento activo');\n      // Iniciar análisis de audio si es posible\n      this.setupAudioAnalysis();\n    };\n    \n    return true;\n  }\n\n  /**\n   * Configura el análisis de audio para mejor detección de voz\n   */\n  setupAudioAnalysis() {\n    // Solo configurar si tenemos acceso al stream\n    if (!this.microphoneStream) return;\n    \n    try {\n      // Crear contexto de audio si no existe\n      if (!this.audioContext) {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        this.audioContext = new AudioContext();\n      }\n      \n      // Crear analizador de audio\n      this.analyser = this.audioContext.createAnalyser();\n      this.analyser.fftSize = 256;\n      \n      // Conectar el stream de micrófono al analizador\n      const source = this.audioContext.createMediaStreamSource(this.microphoneStream);\n      source.connect(this.analyser);\n      \n      // Preparar buffer para datos\n      this.audioData = new Uint8Array(this.analyser.frequencyBinCount);\n      \n      // Iniciar monitoreo de volumen\n      this.startVolumeMonitoring();\n    } catch (error) {\n      console.error('Error al configurar análisis de audio:', error);\n    }\n  }\n\n  /**\n   * Inicia el monitoreo de volumen para mejor detección de voz\n   */\n  startVolumeMonitoring() {\n    // Detener monitoreo previo si existe\n    this.stopVolumeMonitoring();\n    \n    // Iniciar nuevo intervalo de monitoreo\n    this.volumeCheckInterval = setInterval(() => {\n      if (!this.analyser || !this.audioData) return;\n      \n      // Obtener datos de frecuencia actual\n      this.analyser.getByteFrequencyData(this.audioData);\n      \n      // Calcular volumen promedio\n      let sum = 0;\n      for (let i = 0; i < this.audioData.length; i++) {\n        sum += this.audioData[i];\n      }\n      const averageVolume = sum / this.audioData.length;\n      \n      // Umbral de detección de voz (ajustable)\n      const voiceThreshold = 15;\n      \n      if (averageVolume > voiceThreshold) {\n        // Se detectó voz, resetear temporizador de silencio\n        this.resetSilenceTimer();\n      }\n      \n      // Log de debug cada cierto tiempo\n      if (Math.random() < 0.05) { // Solo loggear aproximadamente 5% del tiempo\n        console.log(`AudioService: Volumen promedio: ${averageVolume.toFixed(2)}`);\n      }\n    }, 200); // Comprobar cada 200ms\n  }\n\n  /**\n   * Detiene el monitoreo de volumen\n   */\n  stopVolumeMonitoring() {\n    if (this.volumeCheckInterval) {\n      clearInterval(this.volumeCheckInterval);\n      this.volumeCheckInterval = null;\n    }\n  }\n\n  /**\n   * Detiene el análisis de audio\n   */\n  stopAudioAnalysis() {\n    this.stopVolumeMonitoring();\n    \n    // Liberar recursos de audio\n    if (this.audioContext && this.audioContext.state !== 'closed') {\n      // No cerramos el contexto para poder reutilizarlo, solo desconectamos\n      if (this.analyser) {\n        this.analyser.disconnect();\n        this.analyser = null;\n      }\n    }\n    \n    this.audioData = null;\n  }\n\n  /**\n   * Reinicia el temporizador de silencio\n   */\n  resetSilenceTimer() {\n    // Limpiar temporizador existente\n    if (this.silenceTimer) {\n      clearTimeout(this.silenceTimer);\n      this.silenceTimer = null;\n    }\n    \n    // Configurar nuevo temporizador\n    this.silenceTimer = setTimeout(() => {\n      console.log(`AudioService: Silencio detectado después de ${this.silenceThreshold}ms`);\n      \n      // Si seguimos escuchando, es tiempo de considerar que el usuario ha terminado\n      if (this.isListening) {\n        console.log('AudioService: Deteniendo reconocimiento por silencio prolongado');\n        this.stop();\n      }\n    }, this.silenceThreshold);\n  }\n\n  /**\n   * Método interno para iniciar el reconocimiento (usado para reintentos)\n   */\n  startRecognition() {\n    if (this.recognition) {\n      try {\n        this.recognition.start();\n        this.isListening = true;\n        \n        // Iniciar temporizador de silencio\n        this.resetSilenceTimer();\n        \n        // Configurar temporizador de tiempo máximo de espera\n        setTimeout(() => {\n          if (this.isListening) {\n            console.log(`AudioService: Tiempo máximo de espera (${this.speakingTimeout}ms) alcanzado`);\n            // No detener directamente, sino revisar si hay actividad\n            if (!this.finalTranscript && !this.interimTranscript) {\n              console.log('AudioService: No se detectó voz, deteniendo');\n              this.stop();\n            }\n          }\n        }, this.speakingTimeout);\n        \n        return true;\n      } catch (error) {\n        console.error('Error al iniciar reconocimiento:', error);\n        this.isListening = false;\n        return false;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Solicita permiso para usar el micrófono con opciones mejoradas\n   * @returns {Promise<boolean>} - Promise que resuelve a true si se otorgó permiso, false en caso contrario\n   */\n  async requestMicrophonePermission() {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      try {\n        // Solicitar acceso al micrófono con configuración óptima\n        const constraints = {\n          audio: {\n            echoCancellation: true,\n            noiseSuppression: true,\n            autoGainControl: true,\n            channelCount: 1  // Mono para mejor reconocimiento de voz\n          }\n        };\n        \n        const stream = await navigator.mediaDevices.getUserMedia(constraints);\n        \n        // Almacenar la referencia al stream para poder detenerlo después\n        this.microphoneStream = stream;\n        this.permissionGranted = true;\n        \n        // Notificar que el permiso fue concedido si hay un callback\n        if (this.permissionCallback) {\n          this.permissionCallback(true);\n        }\n        \n        return true;\n      } catch (error) {\n        console.error('Error al solicitar permiso para el micrófono:', error);\n        \n        this.permissionGranted = false;\n        // Notificar que el permiso fue denegado si hay un callback\n        if (this.permissionCallback) {\n          this.permissionCallback(false, error.message);\n        }\n        \n        return false;\n      }\n    } else {\n      console.error('getUserMedia no está soportado en este navegador');\n      return false;\n    }\n  }\n\n  /**\n   * Establece el callback para cuando cambia el estado del permiso del micrófono\n   * @param {Function} callback - Función a llamar cuando cambia el estado del permiso\n   */\n  onPermissionChange(callback) {\n    this.permissionCallback = callback;\n  }\n\n  /**\n   * Configura los tiempos de espera para el reconocimiento de voz\n   * @param {Object} options - Opciones de configuración\n   * @param {number} options.silenceThreshold - Tiempo en ms para considerar silencio (por defecto 3000ms)\n   * @param {number} options.speakingTimeout - Tiempo máximo de espera para una respuesta (por defecto 8000ms)\n   */\n  configureTimings(options = {}) {\n    if (options.silenceThreshold && typeof options.silenceThreshold === 'number') {\n      this.silenceThreshold = options.silenceThreshold;\n    }\n    \n    if (options.speakingTimeout && typeof options.speakingTimeout === 'number') {\n      this.speakingTimeout = options.speakingTimeout;\n    }\n    \n    console.log(`AudioService: Tiempos configurados - Silencio: ${this.silenceThreshold}ms, Espera máxima: ${this.speakingTimeout}ms`);\n  }\n\n  /**\n   * Inicia el reconocimiento de voz, solicitando permisos si es necesario\n   * @param {Object} options - Opciones opcionales para la configuración\n   * @returns {Promise<boolean>} - Promise que resuelve a true si se inició correctamente\n   */\n  async start(options = {}) {\n    // Actualizar configuración si se proporcionan opciones\n    if (options.silenceThreshold || options.speakingTimeout) {\n      this.configureTimings(options);\n    }\n    \n    // Detener cualquier reconocimiento previo primero\n    this.stop();\n    \n    // Pequeña pausa para asegurar que el reconocimiento anterior se detuvo correctamente\n    await new Promise(resolve => setTimeout(resolve, 400));\n    \n    // Verificar y solicitar permiso si no ha sido otorgado\n    if (!this.permissionGranted) {\n      const permissionGranted = await this.requestMicrophonePermission();\n      if (!permissionGranted) {\n        if (this.onErrorCallback) {\n          this.onErrorCallback('No se otorgó permiso para usar el micrófono');\n        }\n        return false;\n      }\n    }\n    \n    if (!this.recognition) {\n      const initialized = this.init(options.language || this.recognitionLang);\n      if (!initialized) return false;\n    }\n    \n    // Reiniciar transcripciones\n    this.finalTranscript = '';\n    this.interimTranscript = '';\n    \n    // Resetear contador de intentos\n    this.restartAttempts = 0;\n    \n    console.log('AudioService: Iniciando reconocimiento de voz');\n    return this.startRecognition();\n  }\n\n  /**\n   * Detiene el reconocimiento de voz\n   */\n  stop() {\n    // Limpiar temporizador de silencio\n    if (this.silenceTimer) {\n      clearTimeout(this.silenceTimer);\n      this.silenceTimer = null;\n    }\n    \n    // Detener análisis de audio\n    this.stopAudioAnalysis();\n    \n    if (this.recognition && this.isListening) {\n      try {\n        this.recognition.stop();\n        this.isListening = false;\n        \n        // También detener el stream del micrófono si existe\n        if (this.microphoneStream) {\n          this.microphoneStream.getTracks().forEach(track => track.stop());\n        }\n        \n        return true;\n      } catch (error) {\n        console.error('Error al detener el reconocimiento de voz:', error);\n        this.isListening = false;\n        return false;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Establece el callback para cuando se recibe un resultado\n   * @param {Function} callback - Función a llamar con el resultado\n   */\n  onResult(callback) {\n    this.onResultCallback = callback;\n  }\n\n  /**\n   * Establece el callback para cuando termina el reconocimiento\n   * @param {Function} callback - Función a llamar al terminar\n   */\n  onEnd(callback) {\n    this.onEndCallback = callback;\n  }\n\n  /**\n   * Establece el callback para cuando ocurre un error\n   * @param {Function} callback - Función a llamar en caso de error\n   */\n  onError(callback) {\n    this.onErrorCallback = callback;\n  }\n\n  /**\n   * Verifica si el navegador soporta reconocimiento de voz\n   * @returns {boolean} - true si es soportado, false si no\n   */\n  isSupportedByBrowser() {\n    return typeof window !== 'undefined' && \n      ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window);\n  }\n  \n  /**\n   * Ajusta la sensibilidad del reconocimiento de voz\n   * @param {Object} options - Opciones de sensibilidad\n   * @param {number} options.silenceThreshold - Tiempo en ms para considerar silencio (3000-10000)\n   * @param {number} options.speakingTimeout - Tiempo máximo de espera para una respuesta (5000-30000)\n   */\n  setSensitivity(options = {}) {\n    // Valores predefinidos para diferentes sensibilidades\n    const sensitivities = {\n      high: { silenceThreshold: 2000, speakingTimeout: 5000 },\n      medium: { silenceThreshold: 3000, speakingTimeout: 8000 },\n      low: { silenceThreshold: 5000, speakingTimeout: 15000 },\n      veryLow: { silenceThreshold: 8000, speakingTimeout: 30000 }\n    };\n    \n    let config = { ...sensitivities.medium };  // Valor por defecto\n    \n    // Si se proporciona un preset de sensibilidad\n    if (options.preset && sensitivities[options.preset]) {\n      config = { ...sensitivities[options.preset] };\n    }\n    \n    // Sobrescribir con valores específicos si se proporcionan\n    if (options.silenceThreshold) config.silenceThreshold = options.silenceThreshold;\n    if (options.speakingTimeout) config.speakingTimeout = options.speakingTimeout;\n    \n    // Aplicar configuración\n    this.configureTimings(config);\n    \n    return config;\n  }\n}\n\n// Exportar una instancia única del servicio\nconst audioService = new AudioService();\nexport default audioService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}